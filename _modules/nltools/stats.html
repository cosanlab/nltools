<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>nltools.stats &#8212; nltools 0.5.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/bootstrap-sphinx.css?v=45361654" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css?v=61a4c737" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=3fadbb4a"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="../../_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>

<!-- Google Analytics -->
<script>
  (function (i, s, o, g, r, a, m) {
    i["GoogleAnalyticsObject"] = r;
    (i[r] =
      i[r] ||
      function () {
        (i[r].q = i[r].q || []).push(arguments);
      }),
      (i[r].l = 1 * new Date());
    (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m);
  })(
    window,
    document,
    "script",
    "https://www.google-analytics.com/analytics.js",
    "ga"
  );

  ga("create", "UA-138438649-1", "auto");
  ga("send", "pageview");
</script>
<!-- End Google Analytics -->

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          nltools</a>
        <span class="navbar-text navbar-version pull-left"><b>0.5.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../install.html">Installation</a></li>
                <li><a href="../../api.html">API</a></li>
                <li><a href="../../auto_examples/index.html">Tutorials</a></li>
                <li><a href="http://www.github.com/ljchang/nltools">Github</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">TOC <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
              
                
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for nltools.stats</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">NeuroLearn Statistics Tools</span>
<span class="sd">===========================</span>

<span class="sd">Tools to help with statistical analyses.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;pearson&quot;</span><span class="p">,</span>
    <span class="s2">&quot;zscore&quot;</span><span class="p">,</span>
    <span class="s2">&quot;fdr&quot;</span><span class="p">,</span>
    <span class="s2">&quot;holm_bonf&quot;</span><span class="p">,</span>
    <span class="s2">&quot;threshold&quot;</span><span class="p">,</span>
    <span class="s2">&quot;multi_threshold&quot;</span><span class="p">,</span>
    <span class="s2">&quot;winsorize&quot;</span><span class="p">,</span>
    <span class="s2">&quot;trim&quot;</span><span class="p">,</span>
    <span class="s2">&quot;calc_bpm&quot;</span><span class="p">,</span>
    <span class="s2">&quot;downsample&quot;</span><span class="p">,</span>
    <span class="s2">&quot;upsample&quot;</span><span class="p">,</span>
    <span class="s2">&quot;fisher_r_to_z&quot;</span><span class="p">,</span>
    <span class="s2">&quot;fisher_z_to_r&quot;</span><span class="p">,</span>
    <span class="s2">&quot;one_sample_permutation&quot;</span><span class="p">,</span>
    <span class="s2">&quot;two_sample_permutation&quot;</span><span class="p">,</span>
    <span class="s2">&quot;correlation_permutation&quot;</span><span class="p">,</span>
    <span class="s2">&quot;matrix_permutation&quot;</span><span class="p">,</span>
    <span class="s2">&quot;make_cosine_basis&quot;</span><span class="p">,</span>
    <span class="s2">&quot;summarize_bootstrap&quot;</span><span class="p">,</span>
    <span class="s2">&quot;regress&quot;</span><span class="p">,</span>
    <span class="s2">&quot;procrustes&quot;</span><span class="p">,</span>
    <span class="s2">&quot;procrustes_distance&quot;</span><span class="p">,</span>
    <span class="s2">&quot;align&quot;</span><span class="p">,</span>
    <span class="s2">&quot;find_spikes&quot;</span><span class="p">,</span>
    <span class="s2">&quot;correlation&quot;</span><span class="p">,</span>
    <span class="s2">&quot;distance_correlation&quot;</span><span class="p">,</span>
    <span class="s2">&quot;transform_pairwise&quot;</span><span class="p">,</span>
    <span class="s2">&quot;double_center&quot;</span><span class="p">,</span>
    <span class="s2">&quot;u_center&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_bootstrap_isc&quot;</span><span class="p">,</span>
    <span class="s2">&quot;isc&quot;</span><span class="p">,</span>
    <span class="s2">&quot;isc_group&quot;</span><span class="p">,</span>
    <span class="s2">&quot;isfc&quot;</span><span class="p">,</span>
    <span class="s2">&quot;isps&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_compute_matrix_correlation&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_phase_mean_angle&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_phase_vector_length&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_butter_bandpass_filter&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_phase_rayleigh_p&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_compute_isc_group&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_permute_isc_group&quot;</span><span class="p">,</span>
    <span class="s2">&quot;align_states&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">ifft</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">pearsonr</span><span class="p">,</span> <span class="n">spearmanr</span><span class="p">,</span> <span class="n">kendalltau</span><span class="p">,</span> <span class="n">norm</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">t</span> <span class="k">as</span> <span class="n">t_dist</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">squareform</span><span class="p">,</span> <span class="n">pdist</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">orthogonal_procrustes</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">procrustes</span> <span class="k">as</span> <span class="n">procrust</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">hilbert</span><span class="p">,</span> <span class="n">butter</span><span class="p">,</span> <span class="n">filtfilt</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">linear_sum_assignment</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">nibabel</span> <span class="k">as</span> <span class="nn">nib</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">attempt_to_import</span><span class="p">,</span> <span class="n">check_square_numpy_matrix</span>
<span class="kn">from</span> <span class="nn">.external.srm</span> <span class="kn">import</span> <span class="n">SRM</span><span class="p">,</span> <span class="n">DetSRM</span>
<span class="kn">from</span> <span class="nn">sklearn.utils</span> <span class="kn">import</span> <span class="n">check_random_state</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">pairwise_distances</span>

<span class="n">MAX_INT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>

<span class="c1"># Optional dependencies</span>
<span class="n">sm</span> <span class="o">=</span> <span class="n">attempt_to_import</span><span class="p">(</span><span class="s2">&quot;statsmodels.tsa.arima.model&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;sm&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="pearson"><a class="viewcode-back" href="../../api.html#nltools.stats.pearson">[docs]</a><span class="k">def</span> <span class="nf">pearson</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Correlates row vector x with each row vector in 2D array y.</span>
<span class="sd">    From neurosynth.stats.py - author: Tal Yarkoni</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    <span class="n">ms</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="kc">None</span><span class="p">)]</span>
    <span class="n">datam</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="n">ms</span>
    <span class="n">datass</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">datam</span> <span class="o">*</span> <span class="n">datam</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1"># datass = np.sqrt(ss(datam, axis=1))</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">datam</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">datam</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">temp</span> <span class="o">/</span> <span class="p">(</span><span class="n">datass</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">datass</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="zscore"><a class="viewcode-back" href="../../api.html#nltools.stats.zscore">[docs]</a><span class="k">def</span> <span class="nf">zscore</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;zscore every column in a pandas dataframe or series.</span>

<span class="sd">    Args:</span>
<span class="sd">        df: (pd.DataFrame) Pandas DataFrame instance</span>

<span class="sd">    Returns:</span>
<span class="sd">        z_data: (pd.DataFrame) z-scored pandas DataFrame or series instance</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span> <span class="o">/</span> <span class="n">x</span><span class="o">.</span><span class="n">std</span><span class="p">())</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">df</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">df</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data is not a Pandas DataFrame or Series instance&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="fdr"><a class="viewcode-back" href="../../api.html#nltools.stats.fdr">[docs]</a><span class="k">def</span> <span class="nf">fdr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine FDR threshold given a p value array and desired false</span>
<span class="sd">    discovery rate q. Written by Tal Yarkoni</span>

<span class="sd">    Args:</span>
<span class="sd">        p: (np.array) vector of p-values</span>
<span class="sd">        q: (float) false discovery rate level</span>

<span class="sd">    Returns:</span>
<span class="sd">        fdr_p: (float) p-value threshold based on independence or positive</span>
<span class="sd">                dependence</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Make sure vector of p-values is a numpy array&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;array contains p-values that are outside the range 0-1&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Does not include valid p-values.&quot;</span><span class="p">)</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">nvox</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">null</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nvox</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">q</span> <span class="o">/</span> <span class="n">nvox</span>
    <span class="n">below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">&lt;=</span> <span class="n">null</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">below</span><span class="p">)]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">below</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span></div>


<div class="viewcode-block" id="holm_bonf"><a class="viewcode-back" href="../../api.html#nltools.stats.holm_bonf">[docs]</a><span class="k">def</span> <span class="nf">holm_bonf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute corrected p-values based on the Holm-Bonferroni method, i.e. step-down procedure applying iteratively less correction to highest p-values. A bit more conservative than fdr, but much more powerful thanvanilla bonferroni.</span>

<span class="sd">    Args:</span>
<span class="sd">        p: (np.array) vector of p-values</span>
<span class="sd">        alpha: (float) alpha level</span>

<span class="sd">    Returns:</span>
<span class="sd">        bonf_p: (float) p-value threshold based on bonferroni</span>
<span class="sd">                step-down procedure</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Make sure vector of p-values is a numpy array&quot;</span><span class="p">)</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">nvox</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">null</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="o">/</span> <span class="p">(</span><span class="n">nvox</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nvox</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">&lt;=</span> <span class="n">null</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">below</span><span class="p">)]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">below</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span></div>


<div class="viewcode-block" id="threshold"><a class="viewcode-back" href="../../api.html#nltools.stats.threshold">[docs]</a><span class="k">def</span> <span class="nf">threshold</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">thr</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">return_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Threshold test image by p-value from p image</span>

<span class="sd">    Args:</span>
<span class="sd">        stat: (Brain_Data) Brain_Data instance of arbitrary statistic metric</span>
<span class="sd">              (e.g., beta, t, etc)</span>
<span class="sd">        p: (Brain_Data) Brain_data instance of p-values</span>
<span class="sd">        threshold: (float) p-value to threshold stat image</span>
<span class="sd">        return_mask: (bool) optionall return the thresholding mask; default False</span>

<span class="sd">    Returns:</span>
<span class="sd">        out: Thresholded Brain_Data instance</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">nltools.data</span> <span class="kn">import</span> <span class="n">Brain_Data</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="n">Brain_Data</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Make sure stat is a Brain_Data instance&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Brain_Data</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Make sure p is a Brain_Data instance&quot;</span><span class="p">)</span>

    <span class="c1"># Create Mask</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">thr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">mask</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">thr</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mask</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Apply Threshold Mask</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">stat</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_mask</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">mask</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="multi_threshold"><a class="viewcode-back" href="../../api.html#nltools.stats.multi_threshold">[docs]</a><span class="k">def</span> <span class="nf">multi_threshold</span><span class="p">(</span><span class="n">t_map</span><span class="p">,</span> <span class="n">p_map</span><span class="p">,</span> <span class="n">thresh</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Threshold test image by multiple p-value from p image</span>

<span class="sd">    Args:</span>
<span class="sd">        stat: (Brain_Data) Brain_Data instance of arbitrary statistic metric</span>
<span class="sd">            (e.g., beta, t, etc)</span>
<span class="sd">        p: (Brain_Data) Brain_data instance of p-values</span>
<span class="sd">        threshold: (list) list of p-values to threshold stat image</span>

<span class="sd">    Returns:</span>
<span class="sd">        out: Thresholded Brain_Data instance</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">nltools.data</span> <span class="kn">import</span> <span class="n">Brain_Data</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_map</span><span class="p">,</span> <span class="n">Brain_Data</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Make sure stat is a Brain_Data instance&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p_map</span><span class="p">,</span> <span class="n">Brain_Data</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Make sure p is a Brain_Data instance&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">thresh</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Make sure thresh is a list of p-values&quot;</span><span class="p">)</span>

    <span class="n">affine</span> <span class="o">=</span> <span class="n">t_map</span><span class="o">.</span><span class="n">to_nifti</span><span class="p">()</span><span class="o">.</span><span class="n">affine</span>
    <span class="n">pos_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">t_map</span><span class="o">.</span><span class="n">to_nifti</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">neg_out</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">pos_out</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">thr</span> <span class="ow">in</span> <span class="n">thresh</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">threshold</span><span class="p">(</span><span class="n">t_map</span><span class="p">,</span> <span class="n">p_map</span><span class="p">,</span> <span class="n">thr</span><span class="o">=</span><span class="n">thr</span><span class="p">)</span>
        <span class="n">t_pos</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">t_pos</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_pos</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
        <span class="n">t_neg</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">t_pos</span><span class="p">)</span>
        <span class="n">t_pos</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">t_neg</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">pos_out</span> <span class="o">=</span> <span class="n">pos_out</span> <span class="o">+</span> <span class="n">t_pos</span><span class="o">.</span><span class="n">to_nifti</span><span class="p">()</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">()</span>
        <span class="n">neg_out</span> <span class="o">=</span> <span class="n">neg_out</span> <span class="o">+</span> <span class="n">t_neg</span><span class="o">.</span><span class="n">to_nifti</span><span class="p">()</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">()</span>
    <span class="n">pos_out</span> <span class="o">=</span> <span class="n">pos_out</span> <span class="o">+</span> <span class="n">neg_out</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">Brain_Data</span><span class="p">(</span><span class="n">nib</span><span class="o">.</span><span class="n">Nifti1Image</span><span class="p">(</span><span class="n">pos_out</span><span class="p">,</span> <span class="n">affine</span><span class="p">))</span></div>


<div class="viewcode-block" id="winsorize"><a class="viewcode-back" href="../../api.html#nltools.stats.winsorize">[docs]</a><span class="k">def</span> <span class="nf">winsorize</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">replace_with_cutoff</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Winsorize a Pandas DataFrame or Series with the largest/lowest value not considered outlier</span>

<span class="sd">    Args:</span>
<span class="sd">        data: (pd.DataFrame, pd.Series) data to winsorize</span>
<span class="sd">        cutoff: (dict) a dictionary with keys {&#39;std&#39;:[low,high]} or</span>
<span class="sd">                {&#39;quantile&#39;:[low,high]}</span>
<span class="sd">        replace_with_cutoff: (bool) If True, replace outliers with cutoff.</span>
<span class="sd">                             If False, replaces outliers with closest</span>
<span class="sd">                             existing values; (default: False)</span>
<span class="sd">    Returns:</span>
<span class="sd">        out: (pd.DataFrame, pd.Series) winsorized data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_transform_outliers</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">replace_with_cutoff</span><span class="o">=</span><span class="n">replace_with_cutoff</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;winsorize&quot;</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="trim"><a class="viewcode-back" href="../../api.html#nltools.stats.trim">[docs]</a><span class="k">def</span> <span class="nf">trim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Trim a Pandas DataFrame or Series by replacing outlier values with NaNs</span>

<span class="sd">    Args:</span>
<span class="sd">        data: (pd.DataFrame, pd.Series) data to trim</span>
<span class="sd">        cutoff: (dict) a dictionary with keys {&#39;std&#39;:[low,high]} or</span>
<span class="sd">                {&#39;quantile&#39;:[low,high]}</span>
<span class="sd">    Returns:</span>
<span class="sd">        out: (pd.DataFrame, pd.Series) trimmed data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_transform_outliers</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">replace_with_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;trim&quot;</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_transform_outliers</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">replace_with_cutoff</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This function is not exposed to user but is called by either trim</span>
<span class="sd">    or winsorize.</span>

<span class="sd">    Args:</span>
<span class="sd">        data: (pd.DataFrame, pd.Series) data to transform</span>
<span class="sd">        cutoff: (dict) a dictionary with keys {&#39;std&#39;:[low,high]} or</span>
<span class="sd">                {&#39;quantile&#39;:[low,high]}</span>
<span class="sd">        replace_with_cutoff: (bool) If True, replace outliers with cutoff.</span>
<span class="sd">                                    If False, replaces outliers with closest</span>
<span class="sd">                                    existing values. (default: False)</span>
<span class="sd">        method: &#39;winsorize&#39; or &#39;trim&#39;</span>

<span class="sd">    Returns:</span>
<span class="sd">        out: (pd.DataFrame, pd.Series) transformed data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># To not overwrite data make a copy</span>

    <span class="k">def</span> <span class="nf">_transform_outliers_sub</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">replace_with_cutoff</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;trim&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Make sure that you are applying winsorize to a pandas dataframe or series.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cutoff</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># calculate cutoff values</span>
            <span class="k">if</span> <span class="s2">&quot;quantile&quot;</span> <span class="ow">in</span> <span class="n">cutoff</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">cutoff</span><span class="p">[</span><span class="s2">&quot;quantile&quot;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s2">&quot;std&quot;</span> <span class="ow">in</span> <span class="n">cutoff</span><span class="p">:</span>
                <span class="n">std</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">cutoff</span><span class="p">[</span><span class="s2">&quot;std&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">cutoff</span><span class="p">[</span><span class="s2">&quot;std&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                <span class="p">]</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">cutoff</span><span class="p">[</span><span class="s2">&quot;std&quot;</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="n">std</span><span class="p">)</span>
            <span class="c1"># if replace_with_cutoff is false, replace with true existing values closest to cutoff</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;winsorize&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">replace_with_cutoff</span><span class="p">:</span>
                <span class="n">q</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                <span class="n">q</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cutoff must be a dictionary with quantile or std keys.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;trim&quot;</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;winsorize&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="c1"># transform each column if a dataframe, if series just transform data</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">_transform_outliers_sub</span><span class="p">(</span>
                <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">col</span><span class="p">],</span>
                <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">,</span>
                <span class="n">replace_with_cutoff</span><span class="o">=</span><span class="n">replace_with_cutoff</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_transform_outliers_sub</span><span class="p">(</span>
            <span class="n">df</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">,</span> <span class="n">replace_with_cutoff</span><span class="o">=</span><span class="n">replace_with_cutoff</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data must be a pandas DataFrame or Series&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="calc_bpm"><a class="viewcode-back" href="../../api.html#nltools.stats.calc_bpm">[docs]</a><span class="k">def</span> <span class="nf">calc_bpm</span><span class="p">(</span><span class="n">beat_interval</span><span class="p">,</span> <span class="n">sampling_freq</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate instantaneous BPM from beat to beat interval</span>

<span class="sd">    Args:</span>
<span class="sd">        beat_interval: (int) number of samples in between each beat</span>
<span class="sd">                        (typically R-R Interval)</span>
<span class="sd">        sampling_freq: (float) sampling frequency in Hz</span>

<span class="sd">    Returns:</span>
<span class="sd">        bpm:  (float) beats per minute for time interval</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">sampling_freq</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">beat_interval</span><span class="p">))</span></div>


<div class="viewcode-block" id="downsample"><a class="viewcode-back" href="../../api.html#nltools.stats.downsample">[docs]</a><span class="k">def</span> <span class="nf">downsample</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">sampling_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_type</span><span class="o">=</span><span class="s2">&quot;samples&quot;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Downsample pandas to a new target frequency or number of samples</span>
<span class="sd">    using averaging.</span>

<span class="sd">    Args:</span>
<span class="sd">        data: (pd.DataFrame, pd.Series) data to downsample</span>
<span class="sd">        sampling_freq:  (float) Sampling frequency of data in hertz</span>
<span class="sd">        target: (float) downsampling target</span>
<span class="sd">        target_type: type of target can be [samples,seconds,hz]</span>
<span class="sd">        method: (str) type of downsample method [&#39;mean&#39;,&#39;median&#39;],</span>
<span class="sd">                default: mean</span>

<span class="sd">    Returns:</span>
<span class="sd">        out: (pd.DataFrame, pd.Series) downsmapled data</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data must by a pandas DataFrame or Series instance.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Metric must be either &#39;mean&#39; or &#39;median&#39; &quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">target_type</span> <span class="o">==</span> <span class="s2">&quot;samples&quot;</span><span class="p">:</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">target</span>
    <span class="k">elif</span> <span class="n">target_type</span> <span class="o">==</span> <span class="s2">&quot;seconds&quot;</span><span class="p">:</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">target</span> <span class="o">*</span> <span class="n">sampling_freq</span>
    <span class="k">elif</span> <span class="n">target_type</span> <span class="o">==</span> <span class="s2">&quot;hz&quot;</span><span class="p">:</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">sampling_freq</span> <span class="o">/</span> <span class="n">target</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Make sure target_type is &quot;samples&quot;, &quot;seconds&quot;, &#39;</span> <span class="s1">&#39; or &quot;hz&quot;.&#39;</span><span class="p">)</span>

    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">n_samples</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">n_samples</span><span class="p">))</span>
    <span class="c1"># if data.shape[0] % n_samples:</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">idx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">))])</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">median</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="upsample"><a class="viewcode-back" href="../../api.html#nltools.stats.upsample">[docs]</a><span class="k">def</span> <span class="nf">upsample</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">sampling_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_type</span><span class="o">=</span><span class="s2">&quot;samples&quot;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Upsample pandas to a new target frequency or number of samples using interpolation.</span>

<span class="sd">    Args:</span>
<span class="sd">        data: (pd.DataFrame, pd.Series) data to upsample</span>
<span class="sd">              (Note: will drop non-numeric columns from DataFrame)</span>
<span class="sd">        sampling_freq:  Sampling frequency of data in hertz</span>
<span class="sd">        target: (float) upsampling target</span>
<span class="sd">        target_type: (str) type of target can be [samples,seconds,hz]</span>
<span class="sd">        method: (str) [&#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;]</span>
<span class="sd">                      where &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39; and &#39;cubic&#39;</span>
<span class="sd">                      refer to a spline interpolation of zeroth, first,</span>
<span class="sd">                      second or third order  (default: linear)</span>
<span class="sd">    Returns:</span>
<span class="sd">        upsampled pandas object</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">methods</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="s2">&quot;zero&quot;</span><span class="p">,</span> <span class="s2">&quot;slinear&quot;</span><span class="p">,</span> <span class="s2">&quot;quadratic&quot;</span><span class="p">,</span> <span class="s2">&quot;cubic&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">methods</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Method must be &#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">target_type</span> <span class="o">==</span> <span class="s2">&quot;samples&quot;</span><span class="p">:</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">target</span>
    <span class="k">elif</span> <span class="n">target_type</span> <span class="o">==</span> <span class="s2">&quot;seconds&quot;</span><span class="p">:</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">target</span> <span class="o">*</span> <span class="n">sampling_freq</span>
    <span class="k">elif</span> <span class="n">target_type</span> <span class="o">==</span> <span class="s2">&quot;hz&quot;</span><span class="p">:</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sampling_freq</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Make sure target_type is &quot;samples&quot;, &quot;seconds&quot;, or &quot;hz&quot;.&#39;</span><span class="p">)</span>

    <span class="n">orig_spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">new_spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
        <span class="n">interpolate</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">orig_spacing</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">new_spacing</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">numeric_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">numeric_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Dropping </span><span class="si">%s</span><span class="s2"> non-numeric columns&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">numeric_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">numeric_data</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">numeric_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">interpolate</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">orig_spacing</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">new_spacing</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data must by a pandas DataFrame or Series instance.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="fisher_r_to_z"><a class="viewcode-back" href="../../api.html#nltools.stats.fisher_r_to_z">[docs]</a><span class="k">def</span> <span class="nf">fisher_r_to_z</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Use Fisher transformation to convert correlation to z score&quot;&quot;&quot;</span>

    <span class="c1"># return .5*np.log((1 + r)/(1 - r))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arctanh</span><span class="p">(</span><span class="n">r</span><span class="p">)</span></div>


<div class="viewcode-block" id="fisher_z_to_r"><a class="viewcode-back" href="../../api.html#nltools.stats.fisher_z_to_r">[docs]</a><span class="k">def</span> <span class="nf">fisher_z_to_r</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Use Fisher transformation to convert correlation to z score&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">z</span><span class="p">)</span></div>


<div class="viewcode-block" id="correlation"><a class="viewcode-back" href="../../api.html#nltools.stats.correlation">[docs]</a><span class="k">def</span> <span class="nf">correlation</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;pearson&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This function calculates the correlation between data1 and data2</span>

<span class="sd">    Args:</span>
<span class="sd">        data1: (np.array) x</span>
<span class="sd">        data2: (np.array) y</span>
<span class="sd">        metric: (str) type of correlation [&quot;spearman&quot; or &quot;pearson&quot; or &quot;kendall&quot;]</span>
<span class="sd">    Returns:</span>
<span class="sd">        r: (np.array) correlations</span>
<span class="sd">        p: (float) p-value</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;spearman&quot;</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">spearmanr</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;pearson&quot;</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">pearsonr</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;kendall&quot;</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">kendalltau</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;metric must be &quot;spearman&quot; or &quot;pearson&quot; or &quot;kendall&quot;&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_permute_sign</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">random_state</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span> <span class="o">*</span> <span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>


<span class="k">def</span> <span class="nf">_permute_group</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">random_state</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
    <span class="n">perm_label</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Group&quot;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">perm_label</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Values&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
        <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">perm_label</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Values&quot;</span><span class="p">]</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_permute_func</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">how</span><span class="p">,</span> <span class="n">include_diag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper function for matrix_permutation.</span>
<span class="sd">    Can take a functon, that would be repeated for calculation.</span>
<span class="sd">    Args:</span>
<span class="sd">        data1: (np.array) squareform matrix</span>
<span class="sd">        data2: flattened np array (same size upper triangle of data1)</span>
<span class="sd">        metric: similarity/distance function from scipy.stats (e.g., spearman, pearson, kendall etc)</span>
<span class="sd">        random_state: random_state instance for permutation</span>
<span class="sd">    Returns:</span>
<span class="sd">        r: r value of function</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">random_state</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

    <span class="n">data_row_id</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">data1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">permuted_ix</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">data_row_id</span><span class="p">)</span>
    <span class="n">new_fmri_dist</span> <span class="o">=</span> <span class="n">data1</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">permuted_ix</span><span class="p">,</span> <span class="n">permuted_ix</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

    <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
        <span class="n">new_fmri_dist</span> <span class="o">=</span> <span class="n">new_fmri_dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">new_fmri_dist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
        <span class="n">new_fmri_dist</span> <span class="o">=</span> <span class="n">new_fmri_dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="n">new_fmri_dist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">include_diag</span><span class="p">:</span>
            <span class="n">new_fmri_dist</span> <span class="o">=</span> <span class="n">new_fmri_dist</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_fmri_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">new_fmri_dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">new_fmri_dist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)],</span>
                    <span class="n">new_fmri_dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="n">new_fmri_dist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)],</span>
                <span class="p">]</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">correlation</span><span class="p">(</span><span class="n">new_fmri_dist</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_calc_pvalue</span><span class="p">(</span><span class="n">all_p</span><span class="p">,</span> <span class="n">stat</span><span class="p">,</span> <span class="n">tail</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculates p value based on distribution of correlations</span>
<span class="sd">    This function is called by the permutation functions</span>
<span class="sd">        all_p: list of correlation values from permutation</span>
<span class="sd">        stat: actual value being tested, i.e., stats[&#39;correlation&#39;] or stats[&#39;mean&#39;]</span>
<span class="sd">        tail: (int) either 2 or 1 for two-tailed p-value or one-tailed</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">denom</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_p</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">tail</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">numer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">all_p</span> <span class="o">&gt;=</span> <span class="n">stat</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">stat</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">all_p</span> <span class="o">&lt;=</span> <span class="n">stat</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">tail</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">numer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">all_p</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stat</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;tail must be either 1 or 2&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">numer</span> <span class="o">/</span> <span class="n">denom</span>


<div class="viewcode-block" id="one_sample_permutation"><a class="viewcode-back" href="../../api.html#nltools.stats.one_sample_permutation">[docs]</a><span class="k">def</span> <span class="nf">one_sample_permutation</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">n_permute</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">tail</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">return_perms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;One sample permutation test using randomization.</span>

<span class="sd">    Args:</span>
<span class="sd">        data: (pd.DataFrame, pd.Series, np.array) data to permute</span>
<span class="sd">        n_permute: (int) number of permutations</span>
<span class="sd">        tail: (int) either 1 for one-tail or 2 for two-tailed test (default: 2)</span>
<span class="sd">        n_jobs: (int) The number of CPUs to use to do the computation.</span>
<span class="sd">                -1 means all CPUs.</span>
<span class="sd">        return_parms: (bool) Return the permutation distribution along with the p-value; default False</span>
<span class="sd">        random_state: (int, None, or np.random.RandomState) Initial random seed (default: None)</span>

<span class="sd">    Returns:</span>
<span class="sd">        stats: (dict) dictionary of permutation results [&#39;mean&#39;,&#39;p&#39;]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">random_state</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
    <span class="n">seeds</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">MAX_INT</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_permute</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">stats</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">data</span><span class="p">)}</span>
    <span class="n">all_p</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
        <span class="n">delayed</span><span class="p">(</span><span class="n">_permute_sign</span><span class="p">)(</span><span class="n">data</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">seeds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_permute</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_calc_pvalue</span><span class="p">(</span><span class="n">all_p</span><span class="p">,</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">],</span> <span class="n">tail</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_perms</span><span class="p">:</span>
        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;perm_dist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_p</span>
    <span class="k">return</span> <span class="n">stats</span></div>


<div class="viewcode-block" id="two_sample_permutation"><a class="viewcode-back" href="../../api.html#nltools.stats.two_sample_permutation">[docs]</a><span class="k">def</span> <span class="nf">two_sample_permutation</span><span class="p">(</span>
    <span class="n">data1</span><span class="p">,</span>
    <span class="n">data2</span><span class="p">,</span>
    <span class="n">n_permute</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
    <span class="n">tail</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">return_perms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Independent sample permutation test.</span>

<span class="sd">    Args:</span>
<span class="sd">        data1: (pd.DataFrame, pd.Series, np.array) dataset 1 to permute</span>
<span class="sd">        data2: (pd.DataFrame, pd.Series, np.array) dataset 2 to permute</span>
<span class="sd">        n_permute: (int) number of permutations</span>
<span class="sd">        tail: (int) either 1 for one-tail or 2 for two-tailed test (default: 2)</span>
<span class="sd">        n_jobs: (int) The number of CPUs to use to do the computation.</span>
<span class="sd">                -1 means all CPUs.</span>
<span class="sd">        return_parms: (bool) Return the permutation distribution along with the p-value; default False</span>
<span class="sd">    Returns:</span>
<span class="sd">        stats: (dict) dictionary of permutation results [&#39;mean&#39;,&#39;p&#39;]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">random_state</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
    <span class="n">seeds</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">MAX_INT</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_permute</span><span class="p">)</span>

    <span class="n">stats</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">data1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">data2</span><span class="p">)}</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;Values&quot;</span><span class="p">:</span> <span class="n">data1</span><span class="p">,</span> <span class="s2">&quot;Group&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data1</span><span class="p">))})</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
        <span class="p">[</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;Values&quot;</span><span class="p">:</span> <span class="n">data2</span><span class="p">,</span> <span class="s2">&quot;Group&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data2</span><span class="p">))})]</span>
    <span class="p">)</span>
    <span class="n">all_p</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
        <span class="n">delayed</span><span class="p">(</span><span class="n">_permute_group</span><span class="p">)(</span><span class="n">data</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">seeds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_permute</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_calc_pvalue</span><span class="p">(</span><span class="n">all_p</span><span class="p">,</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">],</span> <span class="n">tail</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_perms</span><span class="p">:</span>
        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;perm_dist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_p</span>
    <span class="k">return</span> <span class="n">stats</span></div>


<div class="viewcode-block" id="correlation_permutation"><a class="viewcode-back" href="../../api.html#nltools.stats.correlation_permutation">[docs]</a><span class="k">def</span> <span class="nf">correlation_permutation</span><span class="p">(</span>
    <span class="n">data1</span><span class="p">,</span>
    <span class="n">data2</span><span class="p">,</span>
    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;permute&quot;</span><span class="p">,</span>
    <span class="n">n_permute</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;spearman&quot;</span><span class="p">,</span>
    <span class="n">tail</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">return_perms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute correlation and calculate p-value using permutation methods.</span>

<span class="sd">    &#39;permute&#39; method randomly shuffles one of the vectors. This method is recommended</span>
<span class="sd">    for independent data. For timeseries data we recommend using &#39;circle_shift&#39; or</span>
<span class="sd">    &#39;phase_randomize&#39; methods.</span>

<span class="sd">    Args:</span>

<span class="sd">        data1: (pd.DataFrame, pd.Series, np.array) dataset 1 to permute</span>
<span class="sd">        data2: (pd.DataFrame, pd.Series, np.array) dataset 2 to permute</span>
<span class="sd">        n_permute: (int) number of permutations</span>
<span class="sd">        metric: (str) type of association metric [&#39;spearman&#39;,&#39;pearson&#39;,</span>
<span class="sd">                &#39;kendall&#39;]</span>
<span class="sd">        method: (str) type of permutation [&#39;permute&#39;, &#39;circle_shift&#39;, &#39;phase_randomize&#39;]</span>
<span class="sd">        random_state: (int, None, or np.random.RandomState) Initial random seed (default: None)</span>
<span class="sd">        tail: (int) either 1 for one-tail or 2 for two-tailed test (default: 2)</span>
<span class="sd">        n_jobs: (int) The number of CPUs to use to do the computation.</span>
<span class="sd">                -1 means all CPUs.</span>
<span class="sd">        return_parms: (bool) Return the permutation distribution along with the p-value; default False</span>

<span class="sd">    Returns:</span>

<span class="sd">        stats: (dict) dictionary of permutation results [&#39;correlation&#39;,&#39;p&#39;]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Make sure that data1 is the same length as data2&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;permute&quot;</span><span class="p">,</span> <span class="s2">&quot;circle_shift&quot;</span><span class="p">,</span> <span class="s2">&quot;phase_randomize&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Make sure that method is [&#39;permute&#39;, &#39;circle_shift&#39;, &#39;phase_randomize&#39;]&quot;</span>
        <span class="p">)</span>

    <span class="n">random_state</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

    <span class="n">data1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data1</span><span class="p">)</span>
    <span class="n">data2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data2</span><span class="p">)</span>

    <span class="n">stats</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;correlation&quot;</span><span class="p">:</span> <span class="n">correlation</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)[</span><span class="mi">0</span><span class="p">]}</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;permute&quot;</span><span class="p">:</span>
        <span class="n">all_p</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">correlation</span><span class="p">)(</span><span class="n">random_state</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">data1</span><span class="p">),</span> <span class="n">data2</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_permute</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;circle_shift&quot;</span><span class="p">:</span>
        <span class="n">all_p</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">correlation</span><span class="p">)(</span>
                <span class="n">circle_shift</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">),</span> <span class="n">data2</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_permute</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;phase_randomize&quot;</span><span class="p">:</span>
        <span class="n">all_p</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">correlation</span><span class="p">)(</span>
                <span class="n">phase_randomize</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">),</span>
                <span class="n">phase_randomize</span><span class="p">(</span><span class="n">data2</span><span class="p">),</span>
                <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_permute</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">all_p</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">all_p</span><span class="p">]</span>

    <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_calc_pvalue</span><span class="p">(</span><span class="n">all_p</span><span class="p">,</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;correlation&quot;</span><span class="p">],</span> <span class="n">tail</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_perms</span><span class="p">:</span>
        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;perm_dist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_p</span>
    <span class="k">return</span> <span class="n">stats</span></div>


<div class="viewcode-block" id="matrix_permutation"><a class="viewcode-back" href="../../api.html#nltools.stats.matrix_permutation">[docs]</a><span class="k">def</span> <span class="nf">matrix_permutation</span><span class="p">(</span>
    <span class="n">data1</span><span class="p">,</span>
    <span class="n">data2</span><span class="p">,</span>
    <span class="n">n_permute</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;spearman&quot;</span><span class="p">,</span>
    <span class="n">how</span><span class="o">=</span><span class="s2">&quot;upper&quot;</span><span class="p">,</span>
    <span class="n">include_diag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">tail</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">return_perms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Permute 2-dimensional matrix correlation (mantel test).</span>

<span class="sd">    Chen, G. et al. (2016). Untangling the relatedness among correlations,</span>
<span class="sd">    part I: nonparametric approaches to inter-subject correlation analysis</span>
<span class="sd">    at the group level. Neuroimage, 142, 248-259.</span>

<span class="sd">    Args:</span>
<span class="sd">        data1: (pd.DataFrame, np.array) square matrix</span>
<span class="sd">        data2: (pd.DataFrame, np.array) square matrix</span>
<span class="sd">        n_permute: (int) number of permutations</span>
<span class="sd">        metric: (str) type of association metric [&#39;spearman&#39;,&#39;pearson&#39;,</span>
<span class="sd">                &#39;kendall&#39;]</span>
<span class="sd">        how: (str) whether to use the &#39;upper&#39; (default), &#39;lower&#39;, or &#39;full&#39; matrix. The</span>
<span class="sd">            default of &#39;upper&#39; assumes both matrices are symmetric</span>
<span class="sd">        include_diag (bool): only applies if `how=&#39;full&#39;`. Whether to include the</span>
<span class="sd">            diagonal elements in the comparison</span>
<span class="sd">        tail: (int) either 1 for one-tail or 2 for two-tailed test</span>
<span class="sd">              (default: 2)</span>
<span class="sd">        n_jobs: (int) The number of CPUs to use to do the computation.</span>
<span class="sd">                -1 means all CPUs.</span>
<span class="sd">        return_parms: (bool) Return the permutation distribution along with the p-value; default False</span>

<span class="sd">    Returns:</span>
<span class="sd">        stats: (dict) dictionary of permutation results [&#39;correlation&#39;,&#39;p&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">random_state</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
    <span class="n">seeds</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">MAX_INT</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_permute</span><span class="p">)</span>
    <span class="n">sq_data1</span> <span class="o">=</span> <span class="n">check_square_numpy_matrix</span><span class="p">(</span><span class="n">data1</span><span class="p">)</span>
    <span class="n">sq_data2</span> <span class="o">=</span> <span class="n">check_square_numpy_matrix</span><span class="p">(</span><span class="n">data2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
        <span class="n">data1</span> <span class="o">=</span> <span class="n">sq_data1</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">sq_data1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">data2</span> <span class="o">=</span> <span class="n">sq_data2</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">sq_data2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
        <span class="n">data1</span> <span class="o">=</span> <span class="n">sq_data1</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="n">sq_data1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">data2</span> <span class="o">=</span> <span class="n">sq_data2</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="n">sq_data2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">include_diag</span><span class="p">:</span>
            <span class="n">data1</span> <span class="o">=</span> <span class="n">sq_data1</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">data2</span> <span class="o">=</span> <span class="n">sq_data2</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">sq_data1</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">sq_data1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)],</span>
                    <span class="n">sq_data1</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="n">sq_data1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)],</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="n">data2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">sq_data2</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">sq_data2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)],</span>
                    <span class="n">sq_data2</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="n">sq_data2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)],</span>
                <span class="p">]</span>
            <span class="p">)</span>

    <span class="n">stats</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;correlation&quot;</span><span class="p">:</span> <span class="n">correlation</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)[</span><span class="mi">0</span><span class="p">]}</span>

    <span class="n">all_p</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
        <span class="n">delayed</span><span class="p">(</span><span class="n">_permute_func</span><span class="p">)(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">sq_data1</span><span class="p">),</span>
            <span class="n">data2</span><span class="p">,</span>
            <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
            <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
            <span class="n">include_diag</span><span class="o">=</span><span class="n">include_diag</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">seeds</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_permute</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_calc_pvalue</span><span class="p">(</span><span class="n">all_p</span><span class="p">,</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;correlation&quot;</span><span class="p">],</span> <span class="n">tail</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_perms</span><span class="p">:</span>
        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;perm_dist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_p</span>
    <span class="k">return</span> <span class="n">stats</span></div>


<div class="viewcode-block" id="make_cosine_basis"><a class="viewcode-back" href="../../api.html#nltools.stats.make_cosine_basis">[docs]</a><span class="k">def</span> <span class="nf">make_cosine_basis</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">sampling_freq</span><span class="p">,</span> <span class="n">filter_length</span><span class="p">,</span> <span class="n">unit_scale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a series of cosine basis functions for a discrete cosine</span>
<span class="sd">        transform. Based off of implementation in spm_filter and spm_dctmtx</span>
<span class="sd">        because scipy dct can only apply transforms but not return the basis</span>
<span class="sd">        functions. Like SPM, does not add constant (i.e. intercept), but does</span>
<span class="sd">        retain first basis (i.e. sigmoidal/linear drift)</span>

<span class="sd">    Args:</span>
<span class="sd">        nsamples (int): number of observations (e.g. TRs)</span>
<span class="sd">        sampling_freq (float): sampling frequency in hertz (i.e. 1 / TR)</span>
<span class="sd">        filter_length (int): length of filter in seconds</span>
<span class="sd">        unit_scale (true): assure that the basis functions are on the normalized range [-1, 1]; default True</span>
<span class="sd">        drop (int): index of which early/slow bases to drop if any; default is</span>
<span class="sd">            to drop constant (i.e. intercept) like SPM. Unlike SPM, retains</span>
<span class="sd">            first basis (i.e. linear/sigmoidal). Will cumulatively drop bases</span>
<span class="sd">            up to and inclusive of index provided (e.g. 2, drops bases 1 and 2)</span>

<span class="sd">    Returns:</span>
<span class="sd">        out (ndarray): nsamples x number of basis sets numpy array</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Figure out number of basis functions to create</span>
    <span class="n">order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">nsamples</span> <span class="o">*</span> <span class="n">sampling_freq</span><span class="p">)</span> <span class="o">/</span> <span class="n">filter_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nsamples</span><span class="p">)</span>

    <span class="c1"># Initialize basis function matrix</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">order</span><span class="p">))</span>

    <span class="c1"># Add constant</span>
    <span class="n">C</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nsamples</span><span class="p">)</span>

    <span class="c1"># Insert higher order cosine basis functions</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="n">C</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">/</span> <span class="n">nsamples</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nsamples</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Drop intercept ala SPM</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">C</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>

    <span class="k">if</span> <span class="n">C</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Basis function creation failed! nsamples is too small for requested filter_length.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">unit_scale</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">*=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="n">C</span> <span class="o">=</span> <span class="n">C</span><span class="p">[:,</span> <span class="n">drop</span><span class="p">:]</span>

    <span class="k">return</span> <span class="n">C</span></div>


<div class="viewcode-block" id="transform_pairwise"><a class="viewcode-back" href="../../api.html#nltools.stats.transform_pairwise">[docs]</a><span class="k">def</span> <span class="nf">transform_pairwise</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Transforms data into pairs with balanced labels for ranking</span>
<span class="sd">    Transforms a n-class ranking problem into a two-class classification</span>
<span class="sd">    problem. Subclasses implementing particular strategies for choosing</span>
<span class="sd">    pairs should override this method.</span>
<span class="sd">    In this method, all pairs are choosen, except for those that have the</span>
<span class="sd">    same target value. The output is an array of balanced classes, i.e.</span>
<span class="sd">    there are the same number of -1 as +1</span>

<span class="sd">    Reference: &quot;Large Margin Rank Boundaries for Ordinal Regression&quot;,</span>
<span class="sd">    R. Herbrich, T. Graepel, K. Obermayer. Authors: Fabian Pedregosa</span>
<span class="sd">    &lt;fabian@fseoane.net&gt; Alexandre Gramfort &lt;alexandre.gramfort@inria.fr&gt;</span>

<span class="sd">    Args:</span>
<span class="sd">        X: (np.array), shape (n_samples, n_features)</span>
<span class="sd">            The data</span>
<span class="sd">        y: (np.array), shape (n_samples,) or (n_samples, 2)</span>
<span class="sd">            Target labels. If it&#39;s a 2D array, the second column represents</span>
<span class="sd">            the grouping of samples, i.e., samples with different groups will</span>
<span class="sd">            not be considered.</span>

<span class="sd">    Returns:</span>
<span class="sd">        X_trans: (np.array), shape (k, n_feaures)</span>
<span class="sd">            Data as pairs, where k = n_samples * (n_samples-1)) / 2 if grouping</span>
<span class="sd">            values were not passed. If grouping variables exist, then returns</span>
<span class="sd">            values computed for each group.</span>
<span class="sd">        y_trans: (np.array), shape (k,)</span>
<span class="sd">            Output class labels, where classes have values {-1, +1}</span>
<span class="sd">            If y was shape (n_samples, 2), then returns (k, 2) with groups on</span>
<span class="sd">            the second dimension.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">X_new</span><span class="p">,</span> <span class="n">y_new</span><span class="p">,</span> <span class="n">y_group</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">y_ndim</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">y_ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
    <span class="n">comb</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">comb</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># skip if same target or different group</span>
            <span class="k">continue</span>
        <span class="n">X_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="n">y_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
        <span class="n">y_group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="c1"># output balanced classes</span>
        <span class="k">if</span> <span class="n">y_new</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">y_new</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">y_new</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">X_new</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">X_new</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">y_ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X_new</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y_new</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">y_ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X_new</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y_new</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y_group</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span></div>


<span class="k">def</span> <span class="nf">_robust_estimator</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">robust_estimator</span><span class="o">=</span><span class="s2">&quot;hc0&quot;</span><span class="p">,</span> <span class="n">nlags</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes robust sandwich estimators for standard errors used in OLS computation. Types include:</span>
<span class="sd">    &#39;hc0&#39;: Huber (1980) sandwich estimator to return robust standard error estimates.</span>
<span class="sd">    &#39;hc3&#39;: MacKinnon and White (1985) HC3 sandwich estimator. Provides more robustness in smaller samples than HC0 Long &amp; Ervin (2000)</span>
<span class="sd">    &#39;hac&#39;: Newey-West (1987) estimator for robustness to heteroscedasticity as well as serial auto-correlation at given lags.</span>

<span class="sd">    Refs: https://www.wikiwand.com/en/Heteroscedasticity-consistent_standard_errors</span>
<span class="sd">    https://github.com/statsmodels/statsmodels/blob/master/statsmodels/regression/linear_model.py</span>
<span class="sd">    https://cran.r-project.org/web/packages/sandwich/vignettes/sandwich.pdf</span>
<span class="sd">    https://www.stata.com/manuals13/tsnewey.pdf</span>

<span class="sd">    Args:</span>
<span class="sd">        vals (np.ndarray): 1d array of residuals</span>
<span class="sd">        X (np.ndarray): design matrix used in OLS, e.g. Brain_Data().X</span>
<span class="sd">        robust_estimator (str): estimator type, &#39;hc0&#39; (default), &#39;hc3&#39;, or &#39;hac&#39;</span>
<span class="sd">        nlags (int): number of lags, only used with &#39;hac&#39; estimator, default is 1</span>

<span class="sd">    Returns:</span>
<span class="sd">        stderr (np.ndarray): 1d array of standard errors with length == X.shape[1]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">robust_estimator</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;hc0&quot;</span><span class="p">,</span> <span class="s2">&quot;hc3&quot;</span><span class="p">,</span> <span class="s2">&quot;hac&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;robust_estimator must be one of hc0, hc3 or hac&quot;</span><span class="p">)</span>

    <span class="c1"># Make a sandwich!</span>
    <span class="c1"># First we need bread</span>
    <span class="n">bread</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">))</span>

    <span class="c1"># Then we need meat</span>
    <span class="k">if</span> <span class="n">robust_estimator</span> <span class="o">==</span> <span class="s2">&quot;hc0&quot;</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">vals</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">meat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">V</span><span class="p">),</span> <span class="n">X</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">robust_estimator</span> <span class="o">==</span> <span class="s2">&quot;hc3&quot;</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">vals</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bread</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">))))</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">meat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">V</span><span class="p">),</span> <span class="n">X</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">robust_estimator</span> <span class="o">==</span> <span class="s2">&quot;hac&quot;</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nlags</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nlags</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>

        <span class="c1"># First compute lag 0</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">vals</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">meat</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">V</span><span class="p">),</span> <span class="n">X</span><span class="p">)</span>

        <span class="c1"># Now loop over additional lags</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nlags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">l</span><span class="p">:]</span> <span class="o">*</span> <span class="n">vals</span><span class="p">[:</span><span class="o">-</span><span class="n">l</span><span class="p">])</span>
            <span class="n">meat_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">l</span><span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">V</span><span class="p">),</span> <span class="n">X</span><span class="p">[:</span><span class="o">-</span><span class="n">l</span><span class="p">])</span>
            <span class="n">meat_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">[:</span><span class="o">-</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">V</span><span class="p">),</span> <span class="n">X</span><span class="p">[</span><span class="n">l</span><span class="p">:])</span>

            <span class="n">meat</span> <span class="o">+=</span> <span class="n">weights</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">meat_1</span> <span class="o">+</span> <span class="n">meat_2</span><span class="p">)</span>

    <span class="c1"># Then we make a sandwich</span>
    <span class="n">vcv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bread</span><span class="p">,</span> <span class="n">meat</span><span class="p">),</span> <span class="n">bread</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">vcv</span><span class="p">))</span>


<div class="viewcode-block" id="summarize_bootstrap"><a class="viewcode-back" href="../../api.html#nltools.stats.summarize_bootstrap">[docs]</a><span class="k">def</span> <span class="nf">summarize_bootstrap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">save_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate summary of bootstrap samples</span>

<span class="sd">    Args:</span>
<span class="sd">        sample: (Brain_Data) Brain_Data instance of samples</span>
<span class="sd">        save_weights: (bool) save bootstrap weights</span>

<span class="sd">    Returns:</span>
<span class="sd">        output: (dict) dictionary of Brain_Data summary images</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Calculate SE of bootstraps</span>
    <span class="n">wstd</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
    <span class="n">wmean</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">wz</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">wmean</span><span class="p">)</span>
    <span class="n">wz</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">wmean</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="n">wstd</span><span class="o">.</span><span class="n">data</span>
    <span class="n">wp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">wmean</span><span class="p">)</span>
    <span class="n">wp</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">wz</span><span class="o">.</span><span class="n">data</span><span class="p">)))</span>
    <span class="c1"># Create outputs</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="n">wz</span><span class="p">,</span> <span class="s2">&quot;p&quot;</span><span class="p">:</span> <span class="n">wp</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="n">wmean</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">save_weights</span><span class="p">:</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
    <span class="k">return</span> <span class="n">output</span></div>


<span class="k">def</span> <span class="nf">_arma_func</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit an ARMA(p,q) model. If Y is a matrix and not a vector, expects an idx argument that refers to columns of Y. Used by regress().</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;method&quot;</span><span class="p">,</span> <span class="s2">&quot;css-mle&quot;</span><span class="p">)</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;order&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">maxiter</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;maxiter&quot;</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
    <span class="n">disp</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;disp&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">start_ar_lags</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;start_ar_lags&quot;</span><span class="p">,</span> <span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">transparams</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;transparams&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">trend</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;trend&quot;</span><span class="p">,</span> <span class="s2">&quot;nc&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">tsa</span><span class="o">.</span><span class="n">arima_model</span><span class="o">.</span><span class="n">ARMA</span><span class="p">(</span><span class="n">endog</span><span class="o">=</span><span class="n">Y</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">],</span> <span class="n">exog</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">tsa</span><span class="o">.</span><span class="n">arima_model</span><span class="o">.</span><span class="n">ARMA</span><span class="p">(</span><span class="n">endog</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="n">trend</span><span class="o">=</span><span class="n">trend</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">transparams</span><span class="o">=</span><span class="n">transparams</span><span class="p">,</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
            <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span>
            <span class="n">start_ar_lags</span><span class="o">=</span><span class="n">start_ar_lags</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="n">trend</span><span class="o">=</span><span class="n">trend</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">transparams</span><span class="o">=</span><span class="n">transparams</span><span class="p">,</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
            <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span>
            <span class="n">start_ar_lags</span><span class="o">=</span><span class="n">start_ar_lags</span><span class="p">,</span>
            <span class="n">start_params</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">res</span><span class="o">.</span><span class="n">tvalues</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">res</span><span class="o">.</span><span class="n">pvalues</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">res</span><span class="o">.</span><span class="n">df_resid</span><span class="p">,</span>
        <span class="n">res</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="regress"><a class="viewcode-back" href="../../api.html#nltools.stats.regress">[docs]</a><span class="k">def</span> <span class="nf">regress</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;ols&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="o">=</span><span class="s2">&quot;full&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This is a flexible function to run several types of regression models provided X and Y numpy arrays. Y can be a 1d numpy array or 2d numpy array. In the latter case, results will be output with shape 1 x Y.shape[1], in other words fitting a separate regression model to each column of Y.</span>

<span class="sd">    Does NOT add an intercept automatically to the X matrix before fitting like some other software packages. This is left up to the user.</span>

<span class="sd">    This function can compute regression in 3 ways:</span>

<span class="sd">    1. Standard OLS</span>
<span class="sd">    2. OLS with robust sandwich estimators for standard errors. 3 robust types of</span>
<span class="sd">       estimators exist:</span>

<span class="sd">    - &#39;hc0&#39; - classic huber-white estimator robust to heteroscedasticity (default)</span>
<span class="sd">    - &#39;hc3&#39; - a variant on huber-white estimator slightly more conservative when sample sizes are small</span>
<span class="sd">    - &#39;hac&#39; - an estimator robust to both heteroscedasticity and auto-correlation;</span>
<span class="sd">      auto-correlation lag can be controlled with the `nlags` keyword argument; default</span>
<span class="sd">      is 1</span>

<span class="sd">    3. ARMA (auto-regressive moving-average) model (experimental). This model is fit through statsmodels.tsa.arima_model.ARMA, so more information about options can be found there. Any settings can be passed in as kwargs. By default fits a (1,1) model with starting lags of 2. This mode is **computationally intensive** and can take quite a while if Y has many columns.  If Y is a 2d array joblib.Parallel is used for faster fitting by parallelizing fits across columns of Y. Parallelization can be controlled by passing in kwargs. Defaults to multi-threading using 10 separate threads, as threads don&#39;t require large arrays to be duplicated in memory. Defaults are also set to enable memory-mapping for very large arrays if backend=&#39;multiprocessing&#39; to prevent crashes and hangs. Various levels of progress can be monitored using the &#39;disp&#39; (statsmodels) and &#39;verbose&#39; (joblib) keyword arguments with integer values &gt; 0.</span>

<span class="sd">    Args:</span>
<span class="sd">        X (ndarray): design matrix; assumes intercept is included</span>
<span class="sd">        Y (ndarray): dependent variable array; if 2d, a model is fit to each column of Y separately</span>
<span class="sd">        mode (str): kind of model to fit; must be one of &#39;ols&#39; (default), &#39;robust&#39;, or</span>
<span class="sd">        &#39;arma&#39;</span>
<span class="sd">        stats (str): one of &#39;full&#39;, &#39;betas&#39;, &#39;tstats&#39;. Useful to speed up calculation if</span>
<span class="sd">        you know you only need some statistics and not others. Defaults to &#39;full&#39;.</span>
<span class="sd">        robust_estimator (str,optional): kind of robust estimator to use if mode = &#39;robust&#39;; default &#39;hc0&#39;</span>
<span class="sd">        nlags (int,optional): auto-correlation lag correction if mode = &#39;robust&#39; and robust_estimator = &#39;hac&#39;; default 1</span>
<span class="sd">        order (tuple,optional): auto-regressive and moving-average orders for mode = &#39;arma&#39;; default (1,1)</span>
<span class="sd">        kwargs (dict): additional keyword arguments to statsmodels.tsa.arima_model.ARMA and joblib.Parallel</span>

<span class="sd">    Returns:</span>
<span class="sd">        b: coefficients</span>
<span class="sd">        se: standard error of coefficients</span>
<span class="sd">        t: t-statistics (coef/sterr)</span>
<span class="sd">        p : p-values</span>
<span class="sd">        df: degrees of freedom</span>
<span class="sd">        res: residuals</span>

<span class="sd">    Examples:</span>
<span class="sd">        Standard OLS</span>

<span class="sd">        &gt;&gt;&gt; results = regress(X,Y,mode=&#39;ols&#39;)</span>

<span class="sd">        Robust OLS with heteroscedasticity (hc0) robust standard errors</span>

<span class="sd">        &gt;&gt;&gt; results = regress(X,Y,mode=&#39;robust&#39;)</span>

<span class="sd">        Robust OLS with heteroscedasticty and auto-correlation (with lag 2) robust standard errors</span>

<span class="sd">        &gt;&gt;&gt; results = regress(X,Y,mode=&#39;robust&#39;,robust_estimator=&#39;hac&#39;,nlags=2)</span>

<span class="sd">        Auto-regressive mode with auto-regressive and moving-average lags = 1</span>

<span class="sd">        &gt;&gt;&gt; results = regress(X,Y,mode=&#39;arma&#39;,order=(1,1))</span>

<span class="sd">        Auto-regressive model with auto-regressive lag = 2, moving-average lag = 3, and multi-processing instead of multi-threading using 8 cores (this can use a lot of memory if input arrays are very large!).</span>

<span class="sd">        &gt;&gt;&gt; results = regress(X,Y,mode=&#39;arma&#39;,order=(2,3),backend=&#39;multiprocessing&#39;,n_jobs=8)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mode must be a string&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;stats must be a string&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ols&quot;</span><span class="p">,</span> <span class="s2">&quot;robust&quot;</span><span class="p">,</span> <span class="s2">&quot;arma&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mode must be one of &#39;ols&#39;,&#39;robust&#39; or &#39;arma&#39;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">stats</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;full&quot;</span><span class="p">,</span> <span class="s2">&quot;betas&quot;</span><span class="p">,</span> <span class="s2">&quot;tstats&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;stats must be one of &#39;full&#39;, &#39;betas&#39;, &#39;tstats&#39;&quot;</span><span class="p">)</span>

    <span class="c1"># Make sure Y is a 2-D array</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="c1"># Compute standard errors based on regression mode</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;ols&quot;</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;robust&quot;</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">Y</span><span class="p">)</span>

        <span class="c1"># Return betas and stop other computations if that&#39;s all that&#39;s requested</span>
        <span class="k">if</span> <span class="n">stats</span> <span class="o">==</span> <span class="s2">&quot;betas&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

        <span class="c1"># Vanilla OLS</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;ols&quot;</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">stderr</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">))))[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="o">*</span> <span class="n">sigma</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="p">)</span>

        <span class="c1"># OLS with robust sandwich estimator based standard-errors</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;robust&quot;</span><span class="p">:</span>
            <span class="n">robust_estimator</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;robust_estimator&quot;</span><span class="p">,</span> <span class="s2">&quot;hc0&quot;</span><span class="p">)</span>
            <span class="n">nlags</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;nlags&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">axis_func</span> <span class="o">=</span> <span class="p">[</span><span class="n">_robust_estimator</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">robust_estimator</span><span class="p">,</span> <span class="n">nlags</span><span class="p">]</span>
            <span class="n">stderr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="o">*</span><span class="n">axis_func</span><span class="p">)</span>

        <span class="c1"># Then only compute t-stats at voxels where the standard error is at least .000001</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">t</span><span class="p">[</span><span class="n">stderr</span> <span class="o">&gt;</span> <span class="mf">1.0e-6</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">stderr</span> <span class="o">&gt;</span> <span class="mf">1.0e-6</span><span class="p">]</span> <span class="o">/</span> <span class="n">stderr</span><span class="p">[</span><span class="n">stderr</span> <span class="o">&gt;</span> <span class="mf">1.0e-6</span><span class="p">]</span>

        <span class="c1"># Return betas and ts and stop other computations if that&#39;s all that&#39;s requested</span>
        <span class="k">if</span> <span class="n">stats</span> <span class="o">==</span> <span class="s2">&quot;tstats&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">t</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t_dist</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">df</span><span class="p">))</span>

    <span class="c1"># ARMA regression</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;arma&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                <span class="s2">&quot;statsmodels&gt;=0.9.0 is required for ARMA regression. Please install this package manually or install nltools with optional arguments: pip install &#39;nltools[arma]&#39;&quot;</span>
            <span class="p">)</span>
        <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;n_jobs&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">backend</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;backend&quot;</span><span class="p">,</span> <span class="s2">&quot;threading&quot;</span><span class="p">)</span>
        <span class="n">max_nbytes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;max_nbytes&quot;</span><span class="p">,</span> <span class="mf">1e8</span><span class="p">)</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;verbose&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Parallelize if Y vector contains more than 1 column</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;threading&quot;</span> <span class="ow">and</span> <span class="n">n_jobs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">n_jobs</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="n">par_for</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span>
                <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span> <span class="n">max_nbytes</span><span class="o">=</span><span class="n">max_nbytes</span>
            <span class="p">)</span>
            <span class="n">out_arma</span> <span class="o">=</span> <span class="n">par_for</span><span class="p">(</span>
                <span class="n">delayed</span><span class="p">(</span><span class="n">_arma_func</span><span class="p">)(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">)</span>

            <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">out_arma</span><span class="p">])</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">out_arma</span><span class="p">])</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">out_arma</span><span class="p">])</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">elem</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">out_arma</span><span class="p">])</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">elem</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">out_arma</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">_arma_func</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Arma models don&#39;t return stderr, so make a variable for consistent function</span>
        <span class="c1"># return values</span>
        <span class="n">stderr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">b</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
        <span class="n">stderr</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
        <span class="n">t</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
        <span class="n">p</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
        <span class="n">df</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
        <span class="n">res</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
    <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">regress_permutation</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">n_permute</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">tail</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Permuted regression. Permute the design matrix each time by shuffling rows before running the estimation.</span>

<span class="sd">    Args:</span>
<span class="sd">        X (ndarray): design matrix; assumes intercept is included</span>
<span class="sd">        Y (ndarray): dependent variable array; if 2d, a model is fit to each column of Y separately</span>
<span class="sd">        n_permute: (int) number of permutations</span>
<span class="sd">        tail: (int) either 1 for one-tail or 2 for two-tailed test (default: 2)</span>
<span class="sd">        n_jobs: (int) The number of CPUs to use to do the computation. -1 means all CPUs.</span>
<span class="sd">        kwargs: optional argument to regress()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">random_state</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">regress</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">stats</span><span class="o">=</span><span class="s2">&quot;tstats&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tail</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">pos_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">neg_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">tail</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;tail must be 1 or 2&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">X</span><span class="p">[:]</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Running 1-sample sign flip test&quot;</span><span class="p">)</span>
        <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="o">*</span> <span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))[</span>
            <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span>
        <span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Running permuted OLS&quot;</span><span class="p">)</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">permutation</span>

    <span class="c1"># We could optionally Save (X.T * X)^-1 * X.T so we dont have to invert each permutation, but this would require not relying on regress() and because the second-level design mat is probably on the small side we might not actually save that much time</span>
    <span class="c1"># inv = np.linalg.pinv(X)</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_permute</span><span class="p">):</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_t</span> <span class="o">=</span> <span class="n">regress</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="n">Y</span><span class="p">,</span> <span class="n">stats</span><span class="o">=</span><span class="s2">&quot;tstats&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tail</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">_t</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">tail</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">pos_p</span> <span class="o">=</span> <span class="n">_t</span> <span class="o">&gt;=</span> <span class="n">t</span>
            <span class="n">neg_p</span> <span class="o">=</span> <span class="n">_t</span> <span class="o">&lt;=</span> <span class="n">t</span>
            <span class="n">p</span><span class="p">[</span><span class="n">pos_mask</span><span class="p">]</span> <span class="o">+=</span> <span class="n">pos_p</span><span class="p">[</span><span class="n">pos_mask</span><span class="p">]</span>
            <span class="n">p</span><span class="p">[</span><span class="n">neg_mask</span><span class="p">]</span> <span class="o">+=</span> <span class="n">neg_p</span><span class="p">[</span><span class="n">neg_mask</span><span class="p">]</span>
    <span class="n">p</span> <span class="o">/=</span> <span class="n">n_permute</span>

    <span class="k">return</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span>


<div class="viewcode-block" id="align"><a class="viewcode-back" href="../../api.html#nltools.stats.align">[docs]</a><span class="k">def</span> <span class="nf">align</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;deterministic_srm&quot;</span><span class="p">,</span> <span class="n">n_features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Align subject data into a common response model.</span>

<span class="sd">    Can be used to hyperalign source data to target data using</span>
<span class="sd">    Hyperalignment from Dartmouth (i.e., procrustes transformation; see</span>
<span class="sd">    nltools.stats.procrustes) or Shared Response Model from Princeton (see</span>
<span class="sd">    nltools.external.srm). (see nltools.data.Brain_Data.align for aligning</span>
<span class="sd">    a single Brain object to another). Common Model is shared response</span>
<span class="sd">    model or centered target data. Transformed data can be back projected to</span>
<span class="sd">    original data using Tranformation matrix. Inputs must be a list of Brain_Data</span>
<span class="sd">    instances or numpy arrays (observations by features).</span>


<span class="sd">    Args:</span>
<span class="sd">        data: (list) A list of Brain_Data objects</span>
<span class="sd">        method: (str) alignment method to use</span>
<span class="sd">            [&#39;probabilistic_srm&#39;,&#39;deterministic_srm&#39;,&#39;procrustes&#39;]</span>
<span class="sd">        n_features: (int) number of features to align to common space.</span>
<span class="sd">            If None then will select number of voxels</span>
<span class="sd">        axis: (int) axis to align on</span>

<span class="sd">    Returns:</span>
<span class="sd">        out: (dict) a dictionary containing a list of transformed subject</span>
<span class="sd">            matrices, a list of transformation matrices, the shared</span>
<span class="sd">            response matrix, and the intersubject correlation of the shared resposnes</span>

<span class="sd">    Examples:</span>
<span class="sd">        - Hyperalign using procrustes transform:</span>
<span class="sd">            &gt;&gt;&gt; out = align(data, method=&#39;procrustes&#39;)</span>
<span class="sd">        - Align using shared response model:</span>
<span class="sd">            &gt;&gt;&gt; out = align(data, method=&#39;probabilistic_srm&#39;, n_features=None)</span>
<span class="sd">        - Project aligned data into original data:</span>
<span class="sd">            &gt;&gt;&gt; original_data = [np.dot(t.data,tm.T) for t,tm in zip(out[&#39;transformed&#39;], out[&#39;transformation_matrix&#39;])]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">nltools.data</span> <span class="kn">import</span> <span class="n">Brain_Data</span><span class="p">,</span> <span class="n">Adjacency</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Make sure you are inputting data is a list.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Make sure all objects in the list are the same type.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;probabilistic_srm&quot;</span><span class="p">,</span> <span class="s2">&quot;deterministic_srm&quot;</span><span class="p">,</span> <span class="s2">&quot;procrustes&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Method must be [&#39;probabilistic_srm&#39;,&#39;deterministic_srm&#39;,&#39;procrustes&#39;]&quot;</span>
        <span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Brain_Data</span><span class="p">):</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;Brain_Data&quot;</span>
        <span class="n">data_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
        <span class="n">transformation_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;numpy&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Type </span><span class="si">%s</span><span class="s2"> is not implemented yet.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="c1"># Align over time or voxels</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;axis must be 0 or 1.&quot;</span><span class="p">)</span>

    <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;deterministic_srm&quot;</span><span class="p">,</span> <span class="s2">&quot;probabilistic_srm&quot;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">n_features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_features</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;deterministic_srm&quot;</span><span class="p">:</span>
            <span class="n">srm</span> <span class="o">=</span> <span class="n">DetSRM</span><span class="p">(</span><span class="n">features</span><span class="o">=</span><span class="n">n_features</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;probabilistic_srm&quot;</span><span class="p">:</span>
            <span class="n">srm</span> <span class="o">=</span> <span class="n">SRM</span><span class="p">(</span><span class="n">features</span><span class="o">=</span><span class="n">n_features</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">srm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;transformed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">srm</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;common_model&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">srm</span><span class="o">.</span><span class="n">s_</span><span class="o">.</span><span class="n">T</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;transformation_matrix&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">srm</span><span class="o">.</span><span class="n">w_</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;procrustes&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n_features</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Currently must use all voxels.&quot;</span>
                <span class="s2">&quot;Eventually will add a PCA reduction,&quot;</span>
                <span class="s2">&quot;must do this manually for now.&quot;</span>
            <span class="p">)</span>
        <span class="c1">## STEP 0: STANDARDIZE SIZE AND SHAPE##</span>
        <span class="n">sizes_0</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
        <span class="n">sizes_1</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>

        <span class="c1"># find the smallest number of rows</span>
        <span class="n">R</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">sizes_0</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sizes_1</span><span class="p">)</span>

        <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">R</span><span class="p">,</span> <span class="n">C</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># Pad rows with different sizes with zeros</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">R</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="n">C</span> <span class="o">-</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">add</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">missing</span><span class="p">))</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>

        <span class="c1">## STEP 1: CREATE INITIAL AVERAGE TEMPLATE##</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># use first data as template</span>
                <span class="n">template</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">procrustes</span><span class="p">(</span><span class="n">template</span> <span class="o">/</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="n">template</span> <span class="o">+=</span> <span class="n">trans</span>
        <span class="n">template</span> <span class="o">/=</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="c1">## STEP 2: CREATE NEW COMMON TEMPLATE##</span>
        <span class="c1"># align each subj to the template from STEP 1</span>
        <span class="c1"># and create a new common template based on avg</span>
        <span class="n">common</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">procrustes</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">common</span> <span class="o">+=</span> <span class="n">trans</span>
        <span class="n">common</span> <span class="o">/=</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="c1">## STEP 3 (below): ALIGN TO NEW TEMPLATE</span>
        <span class="n">aligned</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">transformation_matrix</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">disparity</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">transformed</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">procrustes</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">aligned</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">transformed</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">transformation_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">disparity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="n">scale</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;transformed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">aligned</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;common_model&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">common</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;transformation_matrix&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformation_matrix</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;disparity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">disparity</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;transformed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">out</span><span class="p">[</span><span class="s2">&quot;transformed&quot;</span><span class="p">]]</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;common_model&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s2">&quot;common_model&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s2">&quot;Brain_Data&quot;</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="s2">&quot;transformation_matrix&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">out</span><span class="p">[</span><span class="s2">&quot;transformation_matrix&quot;</span><span class="p">]]</span>

    <span class="c1"># Calculate Intersubject correlation on aligned components</span>
    <span class="k">if</span> <span class="n">n_features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_features</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s2">&quot;common_model&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">Adjacency</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_features</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">Adjacency</span><span class="p">(</span>
                <span class="mi">1</span>
                <span class="o">-</span> <span class="n">pairwise_distances</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="p">:]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">out</span><span class="p">[</span><span class="s2">&quot;transformed&quot;</span><span class="p">]]),</span>
                    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;correlation&quot;</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;similarity&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="n">out</span><span class="p">[</span><span class="s2">&quot;isc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_features</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s2">&quot;Brain_Data&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;procrustes&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="s2">&quot;transformed&quot;</span><span class="p">]):</span>
                <span class="n">data_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">T</span>
                <span class="n">out</span><span class="p">[</span><span class="s2">&quot;transformed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_out</span>
            <span class="n">common</span> <span class="o">=</span> <span class="n">data_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">common</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s2">&quot;common_model&quot;</span><span class="p">]</span>
            <span class="n">out</span><span class="p">[</span><span class="s2">&quot;common_model&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">common</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="s2">&quot;transformed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">out</span><span class="p">[</span><span class="s2">&quot;transformed&quot;</span><span class="p">]]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="s2">&quot;transformation_matrix&quot;</span><span class="p">]):</span>
            <span class="n">transformation_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">T</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;transformation_matrix&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformation_out</span>

    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="procrustes"><a class="viewcode-back" href="../../api.html#nltools.stats.procrustes">[docs]</a><span class="k">def</span> <span class="nf">procrustes</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Procrustes analysis, a similarity test for two data sets.</span>

<span class="sd">    Each input matrix is a set of points or vectors (the rows of the matrix).</span>
<span class="sd">    The dimension of the space is the number of columns of each matrix. Given</span>
<span class="sd">    two identically sized matrices, procrustes standardizes both such that:</span>
<span class="sd">    - :math:`tr(AA^{T}) = 1`.</span>
<span class="sd">    - Both sets of points are centered around the origin.</span>
<span class="sd">    Procrustes ([1]_, [2]_) then applies the optimal transform to the second</span>
<span class="sd">    matrix (including scaling/dilation, rotations, and reflections) to minimize</span>
<span class="sd">    :math:`M^{2}=\sum(data1-data2)^{2}`, or the sum of the squares of the</span>
<span class="sd">    pointwise differences between the two input datasets.</span>
<span class="sd">    This function was not designed to handle datasets with different numbers of</span>
<span class="sd">    datapoints (rows).  If two data sets have different dimensionality</span>
<span class="sd">    (different number of columns), this function will add columns of zeros to</span>
<span class="sd">    the smaller of the two.</span>

<span class="sd">    Args:</span>
<span class="sd">        data1 : array_like</span>
<span class="sd">            Matrix, n rows represent points in k (columns) space `data1` is the</span>
<span class="sd">            reference data, after it is standardised, the data from `data2`</span>
<span class="sd">            will be transformed to fit the pattern in `data1` (must have &gt;1</span>
<span class="sd">            unique points).</span>
<span class="sd">        data2 : array_like</span>
<span class="sd">            n rows of data in k space to be fit to `data1`.  Must be the  same</span>
<span class="sd">            shape ``(numrows, numcols)`` as data1 (must have &gt;1 unique points).</span>

<span class="sd">    Returns:</span>
<span class="sd">        mtx1 : array_like</span>
<span class="sd">            A standardized version of `data1`.</span>
<span class="sd">        mtx2 : array_like</span>
<span class="sd">            The orientation of `data2` that best fits `data1`. Centered, but not</span>
<span class="sd">            necessarily :math:`tr(AA^{T}) = 1`.</span>
<span class="sd">        disparity : float</span>
<span class="sd">            :math:`M^{2}` as defined above.</span>
<span class="sd">        R : (N, N) ndarray</span>
<span class="sd">            The matrix solution of the orthogonal Procrustes problem.</span>
<span class="sd">            Minimizes the Frobenius norm of dot(data1, R) - data2, subject to</span>
<span class="sd">            dot(R.T, R) == I.</span>
<span class="sd">        scale : float</span>
<span class="sd">            Sum of the singular values of ``dot(data1.T, data2)``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mtx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">mtx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mtx1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">mtx2</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input matrices must be two-dimensional&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mtx1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">mtx2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input matrices must have same number of rows.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mtx1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input matrices must be &gt;0 rows and &gt;0 cols&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mtx1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">mtx2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c1"># Pad with zeros</span>
        <span class="k">if</span> <span class="n">mtx1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mtx2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">mtx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">mtx2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mtx1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mtx1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mtx2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mtx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">mtx1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mtx1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mtx2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mtx1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)</span>

    <span class="c1"># translate all the data to the origin</span>
    <span class="n">mtx1</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mtx1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">mtx2</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mtx2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">norm1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">mtx1</span><span class="p">)</span>
    <span class="n">norm2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">mtx2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">norm1</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">norm2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input matrices must contain &gt;1 unique points&quot;</span><span class="p">)</span>

    <span class="c1"># change scaling of data (in rows) such that trace(mtx*mtx&#39;) = 1</span>
    <span class="n">mtx1</span> <span class="o">/=</span> <span class="n">norm1</span>
    <span class="n">mtx2</span> <span class="o">/=</span> <span class="n">norm2</span>

    <span class="c1"># transform mtx2 to minimize disparity</span>
    <span class="n">R</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">orthogonal_procrustes</span><span class="p">(</span><span class="n">mtx1</span><span class="p">,</span> <span class="n">mtx2</span><span class="p">)</span>
    <span class="n">mtx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mtx2</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span>

    <span class="c1"># measure the dissimilarity between the two datasets</span>
    <span class="n">disparity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">mtx1</span> <span class="o">-</span> <span class="n">mtx2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">mtx1</span><span class="p">,</span> <span class="n">mtx2</span><span class="p">,</span> <span class="n">disparity</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">s</span></div>


<div class="viewcode-block" id="double_center"><a class="viewcode-back" href="../../api.html#nltools.stats.double_center">[docs]</a><span class="k">def</span> <span class="nf">double_center</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Double center a 2d array.</span>

<span class="sd">    Args:</span>
<span class="sd">        mat (ndarray): 2d numpy array</span>

<span class="sd">    Returns:</span>
<span class="sd">        mat (ndarray): double-centered version of input</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Array should be 2d&quot;</span><span class="p">)</span>

    <span class="c1"># keepdims ensures that row/column means are not incorrectly broadcast during    subtraction</span>
    <span class="n">row_mean</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">col_mean</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">grand_mean</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">mat</span> <span class="o">-</span> <span class="n">row_mean</span> <span class="o">-</span> <span class="n">col_mean</span> <span class="o">+</span> <span class="n">grand_mean</span></div>


<div class="viewcode-block" id="u_center"><a class="viewcode-back" href="../../api.html#nltools.stats.u_center">[docs]</a><span class="k">def</span> <span class="nf">u_center</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;U-center a 2d array. U-centering is a bias-corrected form of double-centering</span>

<span class="sd">    Args:</span>
<span class="sd">        mat (ndarray): 2d numpy array</span>

<span class="sd">    Returns:</span>
<span class="sd">        mat (narray): u-centered version of input</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Array should be 2d&quot;</span><span class="p">)</span>

    <span class="n">dim</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">u_mu</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="p">((</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">sum_cols</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">sum_rows</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">u_mu_cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sum_cols</span> <span class="o">/</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">u_mu_rows</span> <span class="o">=</span> <span class="p">(</span><span class="n">sum_rows</span> <span class="o">/</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">)))</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="c1"># Do one operation at a time, to improve broadcasting memory usage.</span>
    <span class="n">out</span> <span class="o">-=</span> <span class="n">u_mu_rows</span>
    <span class="n">out</span> <span class="o">-=</span> <span class="n">u_mu_cols</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="n">u_mu</span>
    <span class="c1"># The diagonal is zero</span>
    <span class="n">out</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="distance_correlation"><a class="viewcode-back" href="../../api.html#nltools.stats.distance_correlation">[docs]</a><span class="k">def</span> <span class="nf">distance_correlation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bias_corrected</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ttest</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the distance correlation betwen 2 arrays to test for multivariate dependence (linear or non-linear). Arrays must match on their first dimension. It&#39;s almost always preferable to compute the bias_corrected version which can also optionally perform a ttest. This ttest operates on a statistic thats ~dcorr^2 and will be also returned.</span>

<span class="sd">    Explanation:</span>
<span class="sd">    Distance correlation involves computing the normalized covariance of two centered euclidean distance matrices. Each distance matrix is the euclidean distance between rows (if x or y are 2d) or scalars (if x or y are 1d). Each matrix is centered prior to computing the covariance either using double-centering or u-centering, which corrects for bias as the number of dimensions increases. U-centering is almost always preferred in all cases. It also permits inference of the normalized covariance between each distance matrix using a one-tailed directional t-test. (Szekely &amp; Rizzo, 2013). While distance correlation is normally bounded between 0 and 1, u-centering can produce negative estimates, which are never significant.</span>

<span class="sd">    Validated against the dcor and dcor.ttest functions in the &#39;energy&#39; R package and the dcor.distance_correlation, dcor.udistance_correlation_sqr, and dcor.independence.distance_correlation_t_test functions in the dcor Python package.</span>

<span class="sd">    Args:</span>
<span class="sd">        x (ndarray): 1d or 2d numpy array of observations by features</span>
<span class="sd">        y (ndarry): 1d or 2d numpy array of observations by features</span>
<span class="sd">        bias_corrected (bool): if false use double-centering which produces a biased-estimate that converges to 1 as the number of dimensions increase. Otherwise used u-centering to correct this bias. **Note** this must be True if ttest=True; default True</span>
<span class="sd">        ttest (bool): perform a ttest using the bias_corrected distance correlation; default False</span>

<span class="sd">    Returns:</span>
<span class="sd">        results (dict): dictionary of results (correlation, t, p, and df.) Optionally, covariance, x variance, and y variance</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Both arrays must be 1d or 2d&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">bias_corrected</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ttest</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bias_corrected must be true to perform ttest!&quot;</span><span class="p">)</span>

    <span class="c1"># 1 compute euclidean distances between pairs of value in each array</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">_x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_x</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">_y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_y</span> <span class="o">=</span> <span class="n">y</span>

    <span class="n">x_dist</span> <span class="o">=</span> <span class="n">squareform</span><span class="p">(</span><span class="n">pdist</span><span class="p">(</span><span class="n">_x</span><span class="p">))</span>
    <span class="n">y_dist</span> <span class="o">=</span> <span class="n">squareform</span><span class="p">(</span><span class="n">pdist</span><span class="p">(</span><span class="n">_y</span><span class="p">))</span>

    <span class="c1"># 2 center each matrix</span>
    <span class="k">if</span> <span class="n">bias_corrected</span><span class="p">:</span>
        <span class="c1"># U-centering</span>
        <span class="n">x_dist_cent</span> <span class="o">=</span> <span class="n">u_center</span><span class="p">(</span><span class="n">x_dist</span><span class="p">)</span>
        <span class="n">y_dist_cent</span> <span class="o">=</span> <span class="n">u_center</span><span class="p">(</span><span class="n">y_dist</span><span class="p">)</span>
        <span class="c1"># Compute covariances using N*(N-3) in denominator</span>
        <span class="n">adjusted_n</span> <span class="o">=</span> <span class="n">_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x_dist_cent</span><span class="p">,</span> <span class="n">y_dist_cent</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">adjusted_n</span>
        <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x_dist_cent</span><span class="p">,</span> <span class="n">x_dist_cent</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">adjusted_n</span>
        <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">y_dist_cent</span><span class="p">,</span> <span class="n">y_dist_cent</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">adjusted_n</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># double-centering</span>
        <span class="n">x_dist_cent</span> <span class="o">=</span> <span class="n">double_center</span><span class="p">(</span><span class="n">x_dist</span><span class="p">)</span>
        <span class="n">y_dist_cent</span> <span class="o">=</span> <span class="n">double_center</span><span class="p">(</span><span class="n">y_dist</span><span class="p">)</span>
        <span class="c1"># Compute covariances using N^2 in denominator</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x_dist_cent</span><span class="p">,</span> <span class="n">y_dist_cent</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x_dist_cent</span><span class="p">,</span> <span class="n">x_dist_cent</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">y_dist_cent</span><span class="p">,</span> <span class="n">y_dist_cent</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

    <span class="c1"># 3 Normalize to get correlation</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">xx</span> <span class="o">*</span> <span class="n">yy</span><span class="p">)</span>
    <span class="n">dcor</span> <span class="o">=</span> <span class="n">xy</span> <span class="o">/</span> <span class="n">denom</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">dcor</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># This will only apply in the bias_corrected case as values can be &lt; 0</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;dcorr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;dcorr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dcor</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bias_corrected</span><span class="p">:</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;dcorr_squared&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dcor</span>
    <span class="k">if</span> <span class="n">ttest</span><span class="p">:</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="p">(</span><span class="n">adjusted_n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dof</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">dcor</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dcor</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">t_dist</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dof</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;t&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;df&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dof</span>

    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="procrustes_distance"><a class="viewcode-back" href="../../api.html#nltools.stats.procrustes_distance">[docs]</a><span class="k">def</span> <span class="nf">procrustes_distance</span><span class="p">(</span>
    <span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">,</span> <span class="n">n_permute</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">tail</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Use procrustes super-position to perform a similarity test between 2 matrices. Matrices need to match in size on their first dimension only, as the smaller matrix on the second dimension will be padded with zeros. After aligning two matrices using the procrustes transformation, use the computed disparity between them (sum of squared error of elements) as a similarity metric. Shuffle the rows of one of the matrices and recompute the disparity to perform inference (Peres-Neto &amp; Jackson, 2001).</span>

<span class="sd">    Args:</span>
<span class="sd">        mat1 (ndarray): 2d numpy array; must have same number of rows as mat2</span>
<span class="sd">        mat2 (ndarray): 1d or 2d numpy array; must have same number of rows as mat1</span>
<span class="sd">        n_permute (int): number of permutation iterations to perform</span>
<span class="sd">        tail (int): either 1 for one-tailed or 2 for two-tailed test; default 2</span>
<span class="sd">        n_jobs (int): The number of CPUs to use to do permutation; default -1 (all)</span>

<span class="sd">    Returns:</span>
<span class="sd">        similarity (float): similarity between matrices bounded between 0 and 1</span>
<span class="sd">        pval (float): permuted p-value</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># raise NotImplementedError(&quot;procrustes distance is not currently implemented&quot;)</span>
    <span class="k">if</span> <span class="n">mat1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">mat2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Both arrays must match on their first dimension&quot;</span><span class="p">)</span>

    <span class="n">random_state</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

    <span class="c1"># Make sure both matrices are 2d and the same dimension via padding</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">mat1</span> <span class="o">=</span> <span class="n">mat1</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">mat2</span> <span class="o">=</span> <span class="n">mat2</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">mat1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mat2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">mat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">mat2</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mat1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="s2">&quot;constant&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">mat2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mat1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">mat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">mat1</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mat2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="s2">&quot;constant&quot;</span><span class="p">)</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">sse</span> <span class="o">=</span> <span class="n">procrust</span><span class="p">(</span><span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">)</span>

    <span class="n">stats</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;similarity&quot;</span><span class="p">:</span> <span class="n">sse</span><span class="p">}</span>
    <span class="n">all_p</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
        <span class="n">delayed</span><span class="p">(</span><span class="n">procrust</span><span class="p">)(</span><span class="n">random_state</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">mat1</span><span class="p">),</span> <span class="n">mat2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_permute</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">all_p</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">all_p</span><span class="p">]</span>

    <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_calc_pvalue</span><span class="p">(</span><span class="n">all_p</span><span class="p">,</span> <span class="n">sse</span><span class="p">,</span> <span class="n">tail</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">stats</span></div>


<div class="viewcode-block" id="find_spikes"><a class="viewcode-back" href="../../api.html#nltools.stats.find_spikes">[docs]</a><span class="k">def</span> <span class="nf">find_spikes</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">global_spike_cutoff</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">diff_spike_cutoff</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Function to identify spikes from fMRI Time Series Data</span>

<span class="sd">    Args:</span>
<span class="sd">        data: Brain_Data or nibabel instance</span>
<span class="sd">        global_spike_cutoff: (int,None) cutoff to identify spikes in global signal</span>
<span class="sd">                             in standard deviations, None indicates do not calculate.</span>
<span class="sd">        diff_spike_cutoff: (int,None) cutoff to identify spikes in average frame difference</span>
<span class="sd">                             in standard deviations, None indicates do not calculate.</span>
<span class="sd">    Returns:</span>
<span class="sd">        pandas dataframe with spikes as indicator variables</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">nltools.data</span> <span class="kn">import</span> <span class="n">Brain_Data</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">global_spike_cutoff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">diff_spike_cutoff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Did not input any cutoffs to identify spikes in this data.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Brain_Data</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">global_mn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">frame_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nib</span><span class="o">.</span><span class="n">Nifti1Image</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nibabel instance does not appear to be 4D data.&quot;</span><span class="p">)</span>
        <span class="n">global_mn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">frame_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">3</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Currently this function can only accomodate Brain_Data and nibabel instances&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">global_spike_cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">global_outliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">global_mn</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">global_mn</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">global_mn</span><span class="p">)</span> <span class="o">*</span> <span class="n">global_spike_cutoff</span>
            <span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">global_mn</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">global_mn</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">global_mn</span><span class="p">)</span> <span class="o">*</span> <span class="n">global_spike_cutoff</span>
            <span class="p">),</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">diff_spike_cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">frame_outliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">frame_diff</span>
                <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">frame_diff</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">frame_diff</span><span class="p">)</span> <span class="o">*</span> <span class="n">diff_spike_cutoff</span>
            <span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">frame_diff</span>
                <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">frame_diff</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">frame_diff</span><span class="p">)</span> <span class="o">*</span> <span class="n">diff_spike_cutoff</span>
            <span class="p">),</span>
        <span class="p">)</span>
    <span class="c1"># build spike regressors</span>
    <span class="n">outlier</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">global_mn</span><span class="p">))],</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;TR&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">global_spike_cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">loc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">global_outliers</span><span class="p">):</span>
            <span class="n">outlier</span><span class="p">[</span><span class="s2">&quot;global_spike&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">outlier</span><span class="p">[</span><span class="s2">&quot;global_spike&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">loc</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># build FD regressors</span>
    <span class="k">if</span> <span class="n">diff_spike_cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">loc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frame_outliers</span><span class="p">):</span>
            <span class="n">outlier</span><span class="p">[</span><span class="s2">&quot;diff_spike&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">outlier</span><span class="p">[</span><span class="s2">&quot;diff_spike&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">loc</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">outlier</span></div>


<span class="k">def</span> <span class="nf">phase_randomize</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform phase randomization on time-series signal</span>

<span class="sd">    This procedure preserves the power spectrum/autocorrelation,</span>
<span class="sd">    but destroys any nonlinear behavior. Based on the algorithm</span>
<span class="sd">    described in:</span>

<span class="sd">    Theiler, J., Galdrikian, B., Longtin, A., Eubank, S., &amp; Farmer, J. D. (1991).</span>
<span class="sd">    Testing for nonlinearity in time series: the method of surrogate data</span>
<span class="sd">    (No. LA-UR-91-3343; CONF-9108181-1). Los Alamos National Lab., NM (United States).</span>

<span class="sd">    Lancaster, G., Iatsenko, D., Pidde, A., Ticcinelli, V., &amp; Stefanovska, A. (2018).</span>
<span class="sd">    Surrogate data for hypothesis testing of physical systems. Physics Reports, 748, 1-60.</span>

<span class="sd">    1. Calculate the Fourier transform ftx of the original signal xn.</span>
<span class="sd">    2. Generate a vector of random phases in the range[0, 2]) with</span>
<span class="sd">       length L/2,where L is the length of the time series.</span>
<span class="sd">    3. As the Fourier transform is symmetrical, to create the new phase</span>
<span class="sd">       randomized vector ftr , multiply the first half of ftx (i.e.the half</span>
<span class="sd">       corresponding to the positive frequencies) by exp(ir) to create the</span>
<span class="sd">       first half of ftr.The remainder of ftr is then the horizontally flipped</span>
<span class="sd">       complex conjugate of the first half.</span>
<span class="sd">    4. Finally, the inverse Fourier transform of ftr gives the FT surrogate.</span>

<span class="sd">    Args:</span>

<span class="sd">        data: (np.array) data (can be 1d or 2d, time by features)</span>
<span class="sd">        random_state: (int, None, or np.random.RandomState) Initial random seed (default: None)</span>

<span class="sd">    Returns:</span>

<span class="sd">        shifted_data: (np.array) phase randomized data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">random_state</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">fft_data</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">pos_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">neg_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pos_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">neg_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">phase_shifts</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos_freq</span><span class="p">)))</span>
        <span class="n">fft_data</span><span class="p">[</span><span class="n">pos_freq</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase_shifts</span><span class="p">)</span>
        <span class="n">fft_data</span><span class="p">[</span><span class="n">neg_freq</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase_shifts</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">phase_shifts</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos_freq</span><span class="p">),</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">fft_data</span><span class="p">[</span><span class="n">pos_freq</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase_shifts</span><span class="p">)</span>
        <span class="n">fft_data</span><span class="p">[</span><span class="n">neg_freq</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase_shifts</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">ifft</span><span class="p">(</span><span class="n">fft_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">circle_shift</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Circle shift data for each feature</span>

<span class="sd">    Args:</span>

<span class="sd">        data: time series (1D or 2D). If 2D, then must be observations by features</span>
<span class="sd">        random_state: (int, None, or np.random.RandomState) Initial random seed (default: None)</span>

<span class="sd">    Returns:</span>

<span class="sd">        shifted data</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">random_state</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">shifted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="n">shift</span><span class="p">:],</span> <span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="n">shift</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">size</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">shifted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">:,</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">)],</span> <span class="n">data</span><span class="p">[:</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">)]])</span>
                <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">shift</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">shifted</span>


<span class="k">def</span> <span class="nf">_bootstrap_isc</span><span class="p">(</span>
    <span class="n">similarity_matrix</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="n">exclude_self_corr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper function to compute bootstrapped ISC from Adjacency Instance</span>

<span class="sd">    This function implements the subject-wise bootstrap method discussed in Chen et al., 2016.</span>

<span class="sd">    Chen, G., Shin, Y. W., Taylor, P. A., Glen, D. R., Reynolds, R. C., Israel, R. B.,</span>
<span class="sd">    &amp; Cox, R. W. (2016). Untangling the relatedness among correlations, part I:</span>
<span class="sd">    nonparametric approaches to inter-subject correlation analysis at the group level.</span>
<span class="sd">    NeuroImage, 142, 248-259.</span>

<span class="sd">    Args:</span>

<span class="sd">        similarity_matrix: (Adjacency) Adjacency matrix of pairwise correlation values</span>
<span class="sd">        metric: (str) type of summary statistic (Default: median)</span>
<span class="sd">        exclude_self_corr: (bool) set correlations with random draws of same subject to NaN (Default: True)</span>
<span class="sd">        random_state: random_state instance for permutation</span>

<span class="sd">    Returns:</span>

<span class="sd">        isc: summary statistic of bootstrapped similarity matrix</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">nltools.data</span> <span class="kn">import</span> <span class="n">Adjacency</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">similarity_matrix</span><span class="p">,</span> <span class="n">Adjacency</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;similarity_matrix must be an Adjacency instance.&quot;</span><span class="p">)</span>

    <span class="n">random_state</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

    <span class="n">square</span> <span class="o">=</span> <span class="n">similarity_matrix</span><span class="o">.</span><span class="n">squareform</span><span class="p">()</span>
    <span class="n">n_sub</span> <span class="o">=</span> <span class="n">square</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">bootstrap_subject</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
        <span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_sub</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">n_sub</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">bootstrap_sample</span> <span class="o">=</span> <span class="n">Adjacency</span><span class="p">(</span>
        <span class="n">square</span><span class="p">[</span><span class="n">bootstrap_subject</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">bootstrap_subject</span><span class="p">],</span> <span class="n">matrix_type</span><span class="o">=</span><span class="s2">&quot;similarity&quot;</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">exclude_self_corr</span><span class="p">:</span>
        <span class="n">bootstrap_sample</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">bootstrap_sample</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">bootstrap_sample</span><span class="o">.</span><span class="n">r_to_z</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bootstrap_sample</span><span class="o">.</span><span class="n">median</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_compute_isc</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper function to compute intersubject correlation from observations by subjects array.</span>

<span class="sd">    Args:</span>
<span class="sd">        data: (pd.DataFrame, np.array) observations by subjects where isc is computed across subjects</span>
<span class="sd">        metric: (str) type of isc metric [&#39;mean&#39;,&#39;median&#39;]</span>

<span class="sd">    Returns:</span>
<span class="sd">        isc: (float) intersubject correlation coefficient</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">nltools.data</span> <span class="kn">import</span> <span class="n">Adjacency</span>

    <span class="n">similarity</span> <span class="o">=</span> <span class="n">Adjacency</span><span class="p">(</span>
        <span class="mi">1</span> <span class="o">-</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;correlation&quot;</span><span class="p">),</span> <span class="n">matrix_type</span><span class="o">=</span><span class="s2">&quot;similarity&quot;</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">similarity</span><span class="o">.</span><span class="n">r_to_z</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">:</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">similarity</span><span class="o">.</span><span class="n">median</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">isc</span>


<div class="viewcode-block" id="isc"><a class="viewcode-back" href="../../api.html#nltools.stats.isc">[docs]</a><span class="k">def</span> <span class="nf">isc</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">n_samples</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">,</span>
    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;bootstrap&quot;</span><span class="p">,</span>
    <span class="n">ci_percentile</span><span class="o">=</span><span class="mi">95</span><span class="p">,</span>
    <span class="n">exclude_self_corr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">return_null</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">tail</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute pairwise intersubject correlation from observations by subjects array.</span>

<span class="sd">    This function computes pairwise intersubject correlations (ISC) using the median as recommended by Chen</span>
<span class="sd">    et al., 2016). However, if the mean is preferred, we compute the mean correlation after performing</span>
<span class="sd">    the fisher r-to-z transformation and then convert back to correlations to minimize artificially</span>
<span class="sd">    inflating the correlation values.</span>

<span class="sd">    There are currently three different methods to compute p-values. These include the classic methods for</span>
<span class="sd">    computing permuted time-series by either circle-shifting the data or phase-randomizing the data</span>
<span class="sd">    (see Lancaster et al., 2018). These methods create random surrogate data while preserving the temporal</span>
<span class="sd">    autocorrelation inherent to the signal. By default, we use the subject-wise bootstrap method from</span>
<span class="sd">    Chen et al., 2016. Instead of recomputing the pairwise ISC using circle_shift or phase_randomization methods,</span>
<span class="sd">    this approach uses the computationally more efficient method of bootstrapping the subjects</span>
<span class="sd">    and computing a new pairwise similarity matrix with randomly selected subjects with replacement.</span>
<span class="sd">    If the same subject is selected multiple times, we set the perfect correlation to a nan with</span>
<span class="sd">    (exclude_self_corr=True). We compute the p-values using the percentile method using the same</span>
<span class="sd">    method in Brainiak.</span>

<span class="sd">    Chen, G., Shin, Y. W., Taylor, P. A., Glen, D. R., Reynolds, R. C., Israel, R. B.,</span>
<span class="sd">    &amp; Cox, R. W. (2016). Untangling the relatedness among correlations, part I:</span>
<span class="sd">    nonparametric approaches to inter-subject correlation analysis at the group level.</span>
<span class="sd">    NeuroImage, 142, 248-259.</span>

<span class="sd">    Hall, P., &amp; Wilson, S. R. (1991). Two guidelines for bootstrap hypothesis testing.</span>
<span class="sd">    Biometrics, 757-762.</span>

<span class="sd">    Lancaster, G., Iatsenko, D., Pidde, A., Ticcinelli, V., &amp; Stefanovska, A. (2018).</span>
<span class="sd">    Surrogate data for hypothesis testing of physical systems. Physics Reports, 748, 1-60.</span>

<span class="sd">    Args:</span>
<span class="sd">        data: (pd.DataFrame, np.array) observations by subjects where isc is computed across subjects</span>
<span class="sd">        n_samples: (int) number of random samples/bootstraps</span>
<span class="sd">        metric: (str) type of isc summary metric [&#39;mean&#39;,&#39;median&#39;]</span>
<span class="sd">        method: (str) method to compute p-values [&#39;bootstrap&#39;, &#39;circle_shift&#39;,&#39;phase_randomize&#39;] (default: bootstrap)</span>
<span class="sd">        tail: (int) either 1 for one-tail or 2 for two-tailed test (default: 2)</span>
<span class="sd">        n_jobs: (int) The number of CPUs to use to do the computation. -1 means all CPUs.</span>
<span class="sd">        return_null: (bool) Return the permutation distribution along with the p-value; default False</span>

<span class="sd">    Returns:</span>
<span class="sd">        stats: (dict) dictionary of permutation results [&#39;correlation&#39;,&#39;p&#39;]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">nltools.data</span> <span class="kn">import</span> <span class="n">Adjacency</span>

    <span class="n">random_state</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;data must be a pandas dataframe or numpy array&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">metric</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;metric must be [&#39;mean&#39;, &#39;median&#39;]&quot;</span><span class="p">)</span>

    <span class="n">stats</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;isc&quot;</span><span class="p">:</span> <span class="n">_compute_isc</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)}</span>

    <span class="n">similarity</span> <span class="o">=</span> <span class="n">Adjacency</span><span class="p">(</span>
        <span class="mi">1</span> <span class="o">-</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;correlation&quot;</span><span class="p">),</span> <span class="n">matrix_type</span><span class="o">=</span><span class="s2">&quot;similarity&quot;</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;bootstrap&quot;</span><span class="p">:</span>
        <span class="n">all_bootstraps</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">_bootstrap_isc</span><span class="p">)(</span>
                <span class="n">similarity</span><span class="p">,</span>
                <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
                <span class="n">exclude_self_corr</span><span class="o">=</span><span class="n">exclude_self_corr</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_calc_pvalue</span><span class="p">(</span><span class="n">all_bootstraps</span> <span class="o">-</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;isc&quot;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;isc&quot;</span><span class="p">],</span> <span class="n">tail</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;circle_shift&quot;</span><span class="p">:</span>
        <span class="n">all_bootstraps</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">_compute_isc</span><span class="p">)(</span>
                <span class="n">circle_shift</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">),</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_calc_pvalue</span><span class="p">(</span><span class="n">all_bootstraps</span><span class="p">,</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;isc&quot;</span><span class="p">],</span> <span class="n">tail</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;phase_randomize&quot;</span><span class="p">:</span>
        <span class="n">all_bootstraps</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">_compute_isc</span><span class="p">)(</span>
                <span class="n">phase_randomize</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">),</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_calc_pvalue</span><span class="p">(</span><span class="n">all_bootstraps</span><span class="p">,</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;isc&quot;</span><span class="p">],</span> <span class="n">tail</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;method can only be [&#39;bootstrap&#39;, &#39;circle_shift&#39;,&#39;phase_randomize&#39;]&quot;</span>
        <span class="p">)</span>

    <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;ci&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_bootstraps</span><span class="p">),</span> <span class="p">(</span><span class="mi">100</span> <span class="o">-</span> <span class="n">ci_percentile</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_bootstraps</span><span class="p">),</span> <span class="n">ci_percentile</span> <span class="o">+</span> <span class="p">(</span><span class="mi">100</span> <span class="o">-</span> <span class="n">ci_percentile</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">),</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">return_null</span><span class="p">:</span>
        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;null_distribution&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_bootstraps</span>

    <span class="k">return</span> <span class="n">stats</span></div>


<span class="k">def</span> <span class="nf">_compute_isc_group</span><span class="p">(</span><span class="n">group1</span><span class="p">,</span> <span class="n">group2</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper function to compute intersubject correlation difference between two groups from either:</span>
<span class="sd">    1) an observations by subjects array</span>
<span class="sd">    2) or an Adjacency instance of a similarity matrix.</span>

<span class="sd">    Args:</span>
<span class="sd">        group1: (pd.DataFrame, np.array, Adjacency) group1 data or similarity matrix</span>
<span class="sd">        group2: (pd.DataFrame, np.array,Adjacency)  group2 data or similarity matrix</span>
<span class="sd">        metric: (str) type of isc metric [&#39;mean&#39;,&#39;median&#39;]</span>

<span class="sd">    Returns:</span>
<span class="sd">        isc: (float) intersubject correlation coefficient difference across groups</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">nltools.data</span> <span class="kn">import</span> <span class="n">Adjacency</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group1</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
        <span class="n">group2</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">group1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">group2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;group1 has a different number of observations from group2.&quot;</span>
            <span class="p">)</span>

        <span class="n">similarity_group1</span> <span class="o">=</span> <span class="n">Adjacency</span><span class="p">(</span>
            <span class="mi">1</span> <span class="o">-</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">group1</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;correlation&quot;</span><span class="p">),</span>
            <span class="n">matrix_type</span><span class="o">=</span><span class="s2">&quot;similarity&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">similarity_group2</span> <span class="o">=</span> <span class="n">Adjacency</span><span class="p">(</span>
            <span class="mi">1</span> <span class="o">-</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">group2</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;correlation&quot;</span><span class="p">),</span>
            <span class="n">matrix_type</span><span class="o">=</span><span class="s2">&quot;similarity&quot;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group1</span><span class="p">,</span> <span class="p">(</span><span class="n">Adjacency</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group2</span><span class="p">,</span> <span class="p">(</span><span class="n">Adjacency</span><span class="p">)):</span>
        <span class="n">similarity_group1</span> <span class="o">=</span> <span class="n">group1</span>
        <span class="n">similarity_group2</span> <span class="o">=</span> <span class="n">group2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;group1 and group2 data must either be a observation by feature matrix or Adjacency instances.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
        <span class="n">isc_group1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">similarity_group1</span><span class="o">.</span><span class="n">r_to_z</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
        <span class="n">isc_group2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">similarity_group2</span><span class="o">.</span><span class="n">r_to_z</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">:</span>
        <span class="n">isc_group1</span> <span class="o">=</span> <span class="n">similarity_group1</span><span class="o">.</span><span class="n">median</span><span class="p">()</span>
        <span class="n">isc_group2</span> <span class="o">=</span> <span class="n">similarity_group2</span><span class="o">.</span><span class="n">median</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">isc_group1</span> <span class="o">-</span> <span class="n">isc_group2</span>


<span class="k">def</span> <span class="nf">_permute_isc_group</span><span class="p">(</span><span class="n">similarity_matrix</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper function to compute ISC differences between groups from Adjacency instance</span>

<span class="sd">    This function implements the subject-wise permutation method discussed in Chen et al., 2016.</span>

<span class="sd">    Chen, G., Shin, Y. W., Taylor, P. A., Glen, D. R., Reynolds, R. C., Israel, R. B.,</span>
<span class="sd">    &amp; Cox, R. W. (2016). Untangling the relatedness among correlations, part I:</span>
<span class="sd">    nonparametric approaches to inter-subject correlation analysis at the group level.</span>
<span class="sd">    NeuroImage, 142, 248-259.</span>

<span class="sd">    Args:</span>

<span class="sd">        similarity_matrix: (Adjacency) Adjacency matrix of pairwise correlation values</span>
<span class="sd">        group: (numpy array) Array indicating group 1 and group 2 order (i.e., np.array([1,1,1,2,2,2]))</span>
<span class="sd">        metric: (str) type of summary statistic (Default: median)</span>
<span class="sd">        exclude_self_corr: (bool) set correlations with random draws of same subject to NaN (Default: True)</span>
<span class="sd">        random_state: random_state instance for permutation</span>

<span class="sd">    Returns:</span>

<span class="sd">        isc: summary statistic of bootstrapped similarity matrix</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">nltools.data</span> <span class="kn">import</span> <span class="n">Adjacency</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">similarity_matrix</span><span class="p">,</span> <span class="n">Adjacency</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;similarity_matrix must be an Adjacency instance.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;group must be a numpy array.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">!=</span> <span class="n">similarity_matrix</span><span class="o">.</span><span class="n">square_shape</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Group array must be the same length as the similarity matrix.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">group</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There must only be 2 unique group ids in the group array.&quot;</span><span class="p">)</span>

    <span class="n">random_state</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

    <span class="n">group1_id</span><span class="p">,</span> <span class="n">group2_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
    <span class="n">permute_group</span> <span class="o">=</span> <span class="n">permute_group</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
    <span class="n">permute_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">permute_group</span> <span class="o">==</span> <span class="n">group1_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">permute_group</span> <span class="o">==</span> <span class="n">group2_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="n">permuted_matrix</span> <span class="o">=</span> <span class="n">similarity_matrix</span><span class="o">.</span><span class="n">squareform</span><span class="p">()[</span><span class="n">permute_order</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">permute_order</span><span class="p">]</span>
    <span class="n">group1_similarity_permuted</span> <span class="o">=</span> <span class="n">Adjacency</span><span class="p">(</span>
        <span class="n">permuted_matrix</span><span class="p">[</span><span class="n">group</span> <span class="o">==</span> <span class="n">group1_id</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">group</span> <span class="o">==</span> <span class="n">group1_id</span><span class="p">],</span>
        <span class="n">matrix_type</span><span class="o">=</span><span class="s2">&quot;similarity&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">group2_similarity_permuted</span> <span class="o">=</span> <span class="n">Adjacency</span><span class="p">(</span>
        <span class="n">permuted_matrix</span><span class="p">[</span><span class="n">group</span> <span class="o">==</span> <span class="n">group2_id</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">group</span> <span class="o">==</span> <span class="n">group2_id</span><span class="p">],</span>
        <span class="n">matrix_type</span><span class="o">=</span><span class="s2">&quot;similarity&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">_compute_isc_group</span><span class="p">(</span>
        <span class="n">group1_similarity_permuted</span><span class="p">,</span> <span class="n">group2_similarity_permuted</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span>
    <span class="p">)</span>


<div class="viewcode-block" id="isc_group"><a class="viewcode-back" href="../../api.html#nltools.stats.isc_group">[docs]</a><span class="k">def</span> <span class="nf">isc_group</span><span class="p">(</span>
    <span class="n">group1</span><span class="p">,</span>
    <span class="n">group2</span><span class="p">,</span>
    <span class="n">n_samples</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">,</span>
    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;permute&quot;</span><span class="p">,</span>
    <span class="n">ci_percentile</span><span class="o">=</span><span class="mi">95</span><span class="p">,</span>
    <span class="n">exclude_self_corr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">return_null</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">tail</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute difference in intersubject correlation between groups.</span>

<span class="sd">    This function computes pairwise intersubject correlations (ISC) using the median as recommended by Chen</span>
<span class="sd">    et al., 2016). However, if the mean is preferred, we compute the mean correlation after performing</span>
<span class="sd">    the fisher r-to-z transformation and then convert back to correlations to minimize artificially</span>
<span class="sd">    inflating the correlation values.</span>

<span class="sd">    There are currently two different methods to compute p-values. By default, we use the subject-wise permutation</span>
<span class="sd">    method recommended Chen et al., 2016. This method combines the two groups and computes pairwise similarity both</span>
<span class="sd">    within and between the groups. Then the group labels are permuted and the mean difference between the two groups</span>
<span class="sd">    are recomputed to generate a null distribution. The second method uses subject-wise bootstrapping, where a new</span>
<span class="sd">    pairwise similarity matrix with randomly selected subjects with replacement is created separately for each group</span>
<span class="sd">    and the ISC difference between these groups is used to generate a null distribution. If the same subject is</span>
<span class="sd">    selected multiple times, we set the perfect correlation to a nan with (exclude_self_corr=True). We compute the</span>
<span class="sd">    p-values using the percentile method (Hall &amp; Wilson, 1991).</span>

<span class="sd">    Chen, G., Shin, Y. W., Taylor, P. A., Glen, D. R., Reynolds, R. C., Israel, R. B.,</span>
<span class="sd">    &amp; Cox, R. W. (2016). Untangling the relatedness among correlations, part I:</span>
<span class="sd">    nonparametric approaches to inter-subject correlation analysis at the group level.</span>
<span class="sd">    NeuroImage, 142, 248-259.</span>

<span class="sd">    Hall, P., &amp; Wilson, S. R. (1991). Two guidelines for bootstrap hypothesis testing.</span>
<span class="sd">    Biometrics, 757-762.</span>

<span class="sd">    Args:</span>
<span class="sd">        group1: (pd.DataFrame, np.array) observations by subjects where isc is computed across subjects</span>
<span class="sd">        group2: (pd.DataFrame, np.array) observations by subjects where isc is computed across subjects</span>
<span class="sd">        n_samples: (int) number of samples for permutation or bootstrapping</span>
<span class="sd">        metric: (str) type of isc summary metric [&#39;mean&#39;,&#39;median&#39;]</span>
<span class="sd">        method: (str) method to compute p-values [&#39;bootstrap&#39;, &#39;circle_shift&#39;,&#39;phase_randomize&#39;] (default: bootstrap)</span>
<span class="sd">        tail: (int) either 1 for one-tail or 2 for two-tailed test (default: 2)</span>
<span class="sd">        n_jobs: (int) The number of CPUs to use to do the computation. -1 means all CPUs.</span>
<span class="sd">        return_null: (bool) Return the permutation distribution along with the p-value; default False</span>

<span class="sd">    Returns:</span>
<span class="sd">        stats: (dict) dictionary of permutation results [&#39;correlation&#39;,&#39;p&#39;]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">nltools.data</span> <span class="kn">import</span> <span class="n">Adjacency</span>

    <span class="n">random_state</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">group_data</span> <span class="ow">in</span> <span class="p">[</span><span class="n">group1</span><span class="p">,</span> <span class="n">group2</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group_data</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;group data must be a pandas dataframe or numpy array&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">metric</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;metric must be [&#39;mean&#39;, &#39;median&#39;]&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">group1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">group2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;group1 has a different number of observations from group2.&quot;</span><span class="p">)</span>

    <span class="n">stats</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;isc_group_difference&quot;</span><span class="p">:</span> <span class="n">_compute_isc_group</span><span class="p">(</span><span class="n">group1</span><span class="p">,</span> <span class="n">group2</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)}</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;permute&quot;</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">group1</span><span class="p">,</span> <span class="n">group2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">group</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">group1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">group2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">similarity</span> <span class="o">=</span> <span class="n">Adjacency</span><span class="p">(</span>
            <span class="mi">1</span> <span class="o">-</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;correlation&quot;</span><span class="p">),</span>
            <span class="n">matrix_type</span><span class="o">=</span><span class="s2">&quot;similarity&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">isc_group_differences_null</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
                <span class="n">delayed</span><span class="p">(</span><span class="n">_permute_isc_group</span><span class="p">)(</span>
                    <span class="n">similarity</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;bootstrap&quot;</span><span class="p">:</span>
        <span class="n">group1_similarity</span> <span class="o">=</span> <span class="n">Adjacency</span><span class="p">(</span>
            <span class="mi">1</span> <span class="o">-</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">group1</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;correlation&quot;</span><span class="p">),</span>
            <span class="n">matrix_type</span><span class="o">=</span><span class="s2">&quot;similarity&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">group1_all_bootstraps</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">_bootstrap_isc</span><span class="p">)(</span>
                <span class="n">group1_similarity</span><span class="p">,</span>
                <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
                <span class="n">exclude_self_corr</span><span class="o">=</span><span class="n">exclude_self_corr</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">group2_similarity</span> <span class="o">=</span> <span class="n">Adjacency</span><span class="p">(</span>
            <span class="mi">1</span> <span class="o">-</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">group2</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;correlation&quot;</span><span class="p">),</span>
            <span class="n">matrix_type</span><span class="o">=</span><span class="s2">&quot;similarity&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">group2_all_bootstraps</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">_bootstrap_isc</span><span class="p">)(</span>
                <span class="n">group2_similarity</span><span class="p">,</span>
                <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
                <span class="n">exclude_self_corr</span><span class="o">=</span><span class="n">exclude_self_corr</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">isc_group_differences_null</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">group1_all_bootstraps</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">group2_all_bootstraps</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;isc_group_difference&quot;</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;method can only be [&#39;permutation&#39;, &#39;bootstrap&#39;]&quot;</span><span class="p">)</span>

    <span class="n">isc_group_differences_null</span> <span class="o">=</span> <span class="n">isc_group_differences_null</span><span class="p">[</span>
        <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">isc_group_differences_null</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_calc_pvalue</span><span class="p">(</span>
        <span class="n">isc_group_differences_null</span><span class="p">,</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;isc_group_difference&quot;</span><span class="p">],</span> <span class="n">tail</span>
    <span class="p">)</span>

    <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;ci&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">isc_group_differences_null</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span> <span class="o">-</span> <span class="n">ci_percentile</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span>
            <span class="n">isc_group_differences_null</span><span class="p">,</span>
            <span class="n">ci_percentile</span> <span class="o">+</span> <span class="p">(</span><span class="mi">100</span> <span class="o">-</span> <span class="n">ci_percentile</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">return_null</span><span class="p">:</span>
        <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;null_distribution&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">isc_group_differences_null</span>

    <span class="k">return</span> <span class="n">stats</span></div>


<span class="k">def</span> <span class="nf">_compute_matrix_correlation</span><span class="p">(</span><span class="n">matrix1</span><span class="p">,</span> <span class="n">matrix2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes the intersubject functional correlation between 2 matrices (observation x feature)&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">matrix1</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">matrix2</span><span class="o">.</span><span class="n">T</span><span class="p">)[</span><span class="n">matrix1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">:,</span> <span class="p">:</span> <span class="n">matrix2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>


<div class="viewcode-block" id="isfc"><a class="viewcode-back" href="../../api.html#nltools.stats.isfc">[docs]</a><span class="k">def</span> <span class="nf">isfc</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;average&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute intersubject functional connectivity (ISFC) from a list of observation x feature matrices</span>

<span class="sd">    This function uses the leave one out approach to compute ISFC (Simony et al., 2016).</span>
<span class="sd">    For each subject, compute the cross-correlation between each voxel/roi</span>
<span class="sd">    with the average of the rest of the subjects data. In other words,</span>
<span class="sd">    compute the mean voxel/ROI response for all participants except the</span>
<span class="sd">    target subject. Then compute the correlation between each ROI within</span>
<span class="sd">    the target subject with the mean ROI response in the group average.</span>

<span class="sd">    Simony, E., Honey, C. J., Chen, J., Lositsky, O., Yeshurun, Y., Wiesel, A., &amp; Hasson, U. (2016).</span>
<span class="sd">    Dynamic reconfiguration of the default mode network during narrative comprehension.</span>
<span class="sd">    Nature communications, 7, 12141.</span>

<span class="sd">    Args:</span>
<span class="sd">        data: list of subject matrices (observations x voxels/rois)</span>
<span class="sd">        method: approach to computing ISFC. &#39;average&#39; uses leave one</span>

<span class="sd">    Returns:</span>
<span class="sd">        list of subject ISFC matrices</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">subjects</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;average&quot;</span><span class="p">:</span>
        <span class="n">sub_isfc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">subjects</span><span class="p">:</span>
            <span class="n">m1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
            <span class="n">sub_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">m1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="p">(</span><span class="n">y</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">subjects</span> <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">target</span><span class="p">):</span>
                <span class="n">sub_mean</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">y</span><span class="p">]</span>
            <span class="n">sub_isfc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">_compute_matrix_correlation</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">sub_mean</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subjects</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Only average method is implemented. Pairwise will be added at some point.&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">sub_isfc</span></div>


<div class="viewcode-block" id="isps"><a class="viewcode-back" href="../../api.html#nltools.stats.isps">[docs]</a><span class="k">def</span> <span class="nf">isps</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sampling_freq</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">low_cut</span><span class="o">=</span><span class="mf">0.04</span><span class="p">,</span> <span class="n">high_cut</span><span class="o">=</span><span class="mf">0.07</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">pairwise</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute Dynamic Intersubject Phase Synchrony (ISPS from a observation by subject array)</span>

<span class="sd">    This function computes the instantaneous intersubject phase synchrony for a single voxel/roi</span>
<span class="sd">    timeseries. Requires multiple subjects. This method is largely based on that described by Glerean</span>
<span class="sd">    et al., 2012 and performs a hilbert transform on narrow bandpass filtered timeseries (butterworth)</span>
<span class="sd">    data to get the instantaneous phase angle. The function returns a dictionary containing the</span>
<span class="sd">    average phase angle, the average vector length, and parametric p-values computed using the rayleigh test using circular</span>
<span class="sd">    statistics (Fisher, 1993). If pairwise=True, then it will compute these on the pairwise phase angle differences,</span>
<span class="sd">    if pairwise=False, it will compute these on the actual phase angles. This is called inter-site phase coupling</span>
<span class="sd">    or inter-trial phase coupling respectively in the EEG literatures.</span>

<span class="sd">    This function requires narrow band filtering your data. As a default we use the recommendations</span>
<span class="sd">    by (Glerean et al., 2012) of .04-.07Hz. This is similar to the &quot;slow-4&quot; band (0.0250.067Hz)</span>
<span class="sd">    described by (Zuo et al., 2010; Penttonen &amp; Buzski, 2003), but excludes the .03 band, which has been</span>
<span class="sd">    demonstrated to contain aliased respiration signals (Birn, 2006).</span>

<span class="sd">    Birn RM, Smith MA, Bandettini PA, Diamond JB. 2006. Separating respiratory-variation-related</span>
<span class="sd">    fluctuations from neuronal-activity- related fluctuations in fMRI. Neuroimage 31:15361548.</span>

<span class="sd">    Buzski, G., &amp; Draguhn, A. (2004). Neuronal oscillations in cortical networks. Science,</span>
<span class="sd">    304(5679), 1926-1929.</span>

<span class="sd">    Fisher, N. I. (1995). Statistical analysis of circular data. cambridge university press.</span>

<span class="sd">    Glerean, E., Salmi, J., Lahnakoski, J. M., Jskelinen, I. P., &amp; Sams, M. (2012).</span>
<span class="sd">    Functional magnetic resonance imaging phase synchronization as a measure of dynamic</span>
<span class="sd">    functional connectivity. Brain connectivity, 2(2), 91-101.</span>

<span class="sd">    Args:</span>
<span class="sd">        data: (pd.DataFrame, np.ndarray) observations x subjects data</span>
<span class="sd">        sampling_freq: (float) sampling freqency of data in Hz</span>
<span class="sd">        low_cut: (float) lower bound cutoff for high pass filter</span>
<span class="sd">        high_cut: (float) upper bound cutoff for low pass filter</span>
<span class="sd">        order: (int) filter order for butterworth bandpass</span>
<span class="sd">        pairwise: (bool) compute phase angle coherence on pairwise phase angle differences</span>
<span class="sd">                or on raw phase angle.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dictionary with mean phase angle, vector length, and rayleigh statistic</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;data must be a pandas dataframe or numpy array (observations by subjects)&quot;</span>
        <span class="p">)</span>

    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span>
        <span class="n">hilbert</span><span class="p">(</span>
            <span class="n">_butter_bandpass_filter</span><span class="p">(</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">low_cut</span><span class="p">,</span> <span class="n">high_cut</span><span class="p">,</span> <span class="n">sampling_freq</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span>
            <span class="p">),</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">pairwise</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">phase</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">phase</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">phase</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">phase</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span>
            <span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;average_angle&quot;</span><span class="p">:</span> <span class="n">_phase_mean_angle</span><span class="p">(</span><span class="n">phase</span><span class="p">)}</span>
    <span class="n">out</span><span class="p">[</span><span class="s2">&quot;vector_length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_phase_vector_length</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span>
    <span class="n">out</span><span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_phase_rayleigh_p</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span></div>


<span class="k">def</span> <span class="nf">_butter_bandpass_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">low_cut</span><span class="p">,</span> <span class="n">high_cut</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply a bandpass butterworth filter with zero-phase filtering</span>

<span class="sd">    Args:</span>
<span class="sd">        data: (np.array)</span>
<span class="sd">        low_cut: (float) lower bound cutoff for high pass filter</span>
<span class="sd">        high_cut: (float) upper bound cutoff for low pass filter</span>
<span class="sd">        fs: (float) sampling frequency in Hz</span>
<span class="sd">        axis: (int) axis to perform filtering.</span>
<span class="sd">        order: (int) filter order for butterworth bandpass</span>

<span class="sd">    Returns:</span>
<span class="sd">        bandpass filtered data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nyq</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">fs</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">butter</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="p">[</span><span class="n">low_cut</span> <span class="o">/</span> <span class="n">nyq</span><span class="p">,</span> <span class="n">high_cut</span> <span class="o">/</span> <span class="n">nyq</span><span class="p">],</span> <span class="n">btype</span><span class="o">=</span><span class="s2">&quot;band&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_phase_mean_angle</span><span class="p">(</span><span class="n">phase_angles</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute mean phase angle using circular statistics</span>

<span class="sd">    Can take 1D (observation for a single feature) or 2D (observation x feature) signals</span>

<span class="sd">    Implementation from:</span>

<span class="sd">        Fisher, N. I. (1995). Statistical analysis of circular data. cambridge university press.</span>

<span class="sd">    Args:</span>
<span class="sd">        phase_angles: (np.array) 1D or 2D array of phase angles</span>

<span class="sd">    Returns:</span>
<span class="sd">        mean phase angle: (np.array)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">phase_angles</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phase_angles</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phase_angles</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_phase_vector_length</span><span class="p">(</span><span class="n">phase_angles</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute vector length of phase angles using circular statistics</span>

<span class="sd">    Can take 1D (observation for a single feature) or 2D (observation x feature) signals</span>

<span class="sd">    Implementation from:</span>

<span class="sd">        Fisher, N. I. (1995). Statistical analysis of circular data. cambridge university press.</span>

<span class="sd">    Args:</span>
<span class="sd">        phase_angles: (np.array) 1D or 2D array of phase angles</span>

<span class="sd">    Returns:</span>
<span class="sd">         phase angle vector length: (np.array)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">phase_angles</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phase_angles</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phase_angles</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="p">)</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_phase_rayleigh_p</span><span class="p">(</span><span class="n">phase_angles</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the p-value of the phase_angles using the Rayleigh statistic</span>

<span class="sd">    Note: this test assumes every time point is independent, which is unlikely to be true in a timeseries with autocorrelation</span>

<span class="sd">    Implementation from:</span>

<span class="sd">        Fisher, N. I. (1995). Statistical analysis of circular data. cambridge university press.</span>

<span class="sd">    Args:</span>
<span class="sd">        phase_angles: (np.array) 1D or 2D array of phase angles</span>

<span class="sd">    Returns:</span>
<span class="sd">         p-values: (np.array)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phase_angles</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">phase_angles</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">phase_angles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">Z</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">_phase_vector_length</span><span class="p">(</span><span class="n">phase_angles</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">50</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">Z</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
            <span class="mi">1</span>
            <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Z</span> <span class="o">-</span> <span class="n">Z</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
            <span class="o">-</span> <span class="p">(</span><span class="mi">24</span> <span class="o">*</span> <span class="n">Z</span> <span class="o">-</span> <span class="mi">132</span> <span class="o">*</span> <span class="n">Z</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">76</span> <span class="o">*</span> <span class="n">Z</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">Z</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">288</span> <span class="o">*</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">Z</span><span class="p">)</span>


<div class="viewcode-block" id="align_states"><a class="viewcode-back" href="../../api.html#nltools.stats.align_states">[docs]</a><span class="k">def</span> <span class="nf">align_states</span><span class="p">(</span>
    <span class="n">reference</span><span class="p">,</span>
    <span class="n">target</span><span class="p">,</span>
    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;correlation&quot;</span><span class="p">,</span>
    <span class="n">return_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">replace_zero_variance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Align state weight maps using hungarian algorithm by minimizing pairwise distance between group states.</span>

<span class="sd">    Args:</span>
<span class="sd">        reference: (np.array) reference pattern x state matrix</span>
<span class="sd">        target: (np.array) target pattern x state matrix to align to reference</span>
<span class="sd">        metric: (str) distance metric to use</span>
<span class="sd">        return_index: (bool) return index if True, return remapped data if False</span>
<span class="sd">        replace_zero_variance: (bool) transform a vector with zero variance to random numbers from a uniform distribution.</span>
<span class="sd">                                Useful for when using correlation as a distance metric to avoid NaNs.</span>
<span class="sd">    Returns:</span>
<span class="sd">        ordered_weights: (list) a list of reordered state X pattern matrices</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">reference</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;reference and target must be the same size&quot;</span><span class="p">)</span>

    <span class="n">reference</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">replace_zero_variance_columns</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">if</span> <span class="n">replace_zero_variance</span><span class="p">:</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="n">replace_zero_variance_columns</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">replace_zero_variance_columns</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

    <span class="n">remapping</span> <span class="o">=</span> <span class="n">linear_sum_assignment</span><span class="p">(</span>
        <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">reference</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>
    <span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">return_index</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">remapping</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">target</span><span class="p">[:,</span> <span class="n">remapping</span><span class="p">]</span></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2023, Cosan Laboratory.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 7.1.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>