<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>API Reference &#8212; nltools 0.5.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/bootstrap-sphinx.css?v=45361654" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery.css?v=61a4c737" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=3fadbb4a"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>

<!-- Google Analytics -->
<script>
  (function (i, s, o, g, r, a, m) {
    i["GoogleAnalyticsObject"] = r;
    (i[r] =
      i[r] ||
      function () {
        (i[r].q = i[r].q || []).push(arguments);
      }),
      (i[r].l = 1 * new Date());
    (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m);
  })(
    window,
    document,
    "script",
    "https://www.google-analytics.com/analytics.js",
    "ga"
  );

  ga("create", "UA-138438649-1", "auto");
  ga("send", "pageview");
</script>
<!-- End Google Analytics -->

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          nltools</a>
        <span class="navbar-text navbar-version pull-left"><b>0.5.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="install.html">Installation</a></li>
                <li><a href="#">API</a></li>
                <li><a href="auto_examples/index.html">Tutorials</a></li>
                <li><a href="http://www.github.com/ljchang/nltools">Github</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">TOC <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">API Reference</a><ul>
<li><a class="reference internal" href="#nltools-data-data-types"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.data</span></code>: Data Types</a><ul>
<li><a class="reference internal" href="#nltools.data.Brain_Data"><code class="docutils literal notranslate"><span class="pre">Brain_Data</span></code></a><ul>
<li><a class="reference internal" href="#nltools.data.Brain_Data.aggregate"><code class="docutils literal notranslate"><span class="pre">Brain_Data.aggregate()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.align"><code class="docutils literal notranslate"><span class="pre">Brain_Data.align()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.append"><code class="docutils literal notranslate"><span class="pre">Brain_Data.append()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.apply_mask"><code class="docutils literal notranslate"><span class="pre">Brain_Data.apply_mask()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.astype"><code class="docutils literal notranslate"><span class="pre">Brain_Data.astype()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.bootstrap"><code class="docutils literal notranslate"><span class="pre">Brain_Data.bootstrap()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.copy"><code class="docutils literal notranslate"><span class="pre">Brain_Data.copy()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.decompose"><code class="docutils literal notranslate"><span class="pre">Brain_Data.decompose()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.detrend"><code class="docutils literal notranslate"><span class="pre">Brain_Data.detrend()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.distance"><code class="docutils literal notranslate"><span class="pre">Brain_Data.distance()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.dtype"><code class="docutils literal notranslate"><span class="pre">Brain_Data.dtype()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.empty"><code class="docutils literal notranslate"><span class="pre">Brain_Data.empty()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.extract_roi"><code class="docutils literal notranslate"><span class="pre">Brain_Data.extract_roi()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.filter"><code class="docutils literal notranslate"><span class="pre">Brain_Data.filter()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.find_spikes"><code class="docutils literal notranslate"><span class="pre">Brain_Data.find_spikes()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.groupby"><code class="docutils literal notranslate"><span class="pre">Brain_Data.groupby()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.icc"><code class="docutils literal notranslate"><span class="pre">Brain_Data.icc()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.iplot"><code class="docutils literal notranslate"><span class="pre">Brain_Data.iplot()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.isempty"><code class="docutils literal notranslate"><span class="pre">Brain_Data.isempty()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.mean"><code class="docutils literal notranslate"><span class="pre">Brain_Data.mean()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.median"><code class="docutils literal notranslate"><span class="pre">Brain_Data.median()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.multivariate_similarity"><code class="docutils literal notranslate"><span class="pre">Brain_Data.multivariate_similarity()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.plot"><code class="docutils literal notranslate"><span class="pre">Brain_Data.plot()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.predict"><code class="docutils literal notranslate"><span class="pre">Brain_Data.predict()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.predict_multi"><code class="docutils literal notranslate"><span class="pre">Brain_Data.predict_multi()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.r_to_z"><code class="docutils literal notranslate"><span class="pre">Brain_Data.r_to_z()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.randomise"><code class="docutils literal notranslate"><span class="pre">Brain_Data.randomise()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.regions"><code class="docutils literal notranslate"><span class="pre">Brain_Data.regions()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.regress"><code class="docutils literal notranslate"><span class="pre">Brain_Data.regress()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.scale"><code class="docutils literal notranslate"><span class="pre">Brain_Data.scale()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.shape"><code class="docutils literal notranslate"><span class="pre">Brain_Data.shape()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.similarity"><code class="docutils literal notranslate"><span class="pre">Brain_Data.similarity()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.smooth"><code class="docutils literal notranslate"><span class="pre">Brain_Data.smooth()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.standardize"><code class="docutils literal notranslate"><span class="pre">Brain_Data.standardize()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.std"><code class="docutils literal notranslate"><span class="pre">Brain_Data.std()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.sum"><code class="docutils literal notranslate"><span class="pre">Brain_Data.sum()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.temporal_resample"><code class="docutils literal notranslate"><span class="pre">Brain_Data.temporal_resample()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.threshold"><code class="docutils literal notranslate"><span class="pre">Brain_Data.threshold()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.to_nifti"><code class="docutils literal notranslate"><span class="pre">Brain_Data.to_nifti()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.transform_pairwise"><code class="docutils literal notranslate"><span class="pre">Brain_Data.transform_pairwise()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.ttest"><code class="docutils literal notranslate"><span class="pre">Brain_Data.ttest()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.upload_neurovault"><code class="docutils literal notranslate"><span class="pre">Brain_Data.upload_neurovault()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.write"><code class="docutils literal notranslate"><span class="pre">Brain_Data.write()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Brain_Data.z_to_r"><code class="docutils literal notranslate"><span class="pre">Brain_Data.z_to_r()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#nltools.data.Adjacency"><code class="docutils literal notranslate"><span class="pre">Adjacency</span></code></a><ul>
<li><a class="reference internal" href="#nltools.data.Adjacency.append"><code class="docutils literal notranslate"><span class="pre">Adjacency.append()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.bootstrap"><code class="docutils literal notranslate"><span class="pre">Adjacency.bootstrap()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.cluster_summary"><code class="docutils literal notranslate"><span class="pre">Adjacency.cluster_summary()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.copy"><code class="docutils literal notranslate"><span class="pre">Adjacency.copy()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.distance"><code class="docutils literal notranslate"><span class="pre">Adjacency.distance()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.distance_to_similarity"><code class="docutils literal notranslate"><span class="pre">Adjacency.distance_to_similarity()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.generate_permutations"><code class="docutils literal notranslate"><span class="pre">Adjacency.generate_permutations()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.isc"><code class="docutils literal notranslate"><span class="pre">Adjacency.isc()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.isc_group"><code class="docutils literal notranslate"><span class="pre">Adjacency.isc_group()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.isempty"><code class="docutils literal notranslate"><span class="pre">Adjacency.isempty()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.mean"><code class="docutils literal notranslate"><span class="pre">Adjacency.mean()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.median"><code class="docutils literal notranslate"><span class="pre">Adjacency.median()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.plot"><code class="docutils literal notranslate"><span class="pre">Adjacency.plot()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.plot_label_distance"><code class="docutils literal notranslate"><span class="pre">Adjacency.plot_label_distance()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.plot_mds"><code class="docutils literal notranslate"><span class="pre">Adjacency.plot_mds()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.plot_silhouette"><code class="docutils literal notranslate"><span class="pre">Adjacency.plot_silhouette()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.r_to_z"><code class="docutils literal notranslate"><span class="pre">Adjacency.r_to_z()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.regress"><code class="docutils literal notranslate"><span class="pre">Adjacency.regress()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.shape"><code class="docutils literal notranslate"><span class="pre">Adjacency.shape()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.similarity"><code class="docutils literal notranslate"><span class="pre">Adjacency.similarity()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.social_relations_model"><code class="docutils literal notranslate"><span class="pre">Adjacency.social_relations_model()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.square_shape"><code class="docutils literal notranslate"><span class="pre">Adjacency.square_shape()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.squareform"><code class="docutils literal notranslate"><span class="pre">Adjacency.squareform()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.stats_label_distance"><code class="docutils literal notranslate"><span class="pre">Adjacency.stats_label_distance()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.std"><code class="docutils literal notranslate"><span class="pre">Adjacency.std()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.sum"><code class="docutils literal notranslate"><span class="pre">Adjacency.sum()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.threshold"><code class="docutils literal notranslate"><span class="pre">Adjacency.threshold()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.to_graph"><code class="docutils literal notranslate"><span class="pre">Adjacency.to_graph()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.ttest"><code class="docutils literal notranslate"><span class="pre">Adjacency.ttest()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.write"><code class="docutils literal notranslate"><span class="pre">Adjacency.write()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Adjacency.z_to_r"><code class="docutils literal notranslate"><span class="pre">Adjacency.z_to_r()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#nltools.data.Groupby"><code class="docutils literal notranslate"><span class="pre">Groupby</span></code></a><ul>
<li><a class="reference internal" href="#nltools.data.Groupby.apply"><code class="docutils literal notranslate"><span class="pre">Groupby.apply()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Groupby.combine"><code class="docutils literal notranslate"><span class="pre">Groupby.combine()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Groupby.split"><code class="docutils literal notranslate"><span class="pre">Groupby.split()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#nltools.data.Design_Matrix"><code class="docutils literal notranslate"><span class="pre">Design_Matrix</span></code></a><ul>
<li><a class="reference internal" href="#nltools.data.Design_Matrix.add_dct_basis"><code class="docutils literal notranslate"><span class="pre">Design_Matrix.add_dct_basis()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Design_Matrix.add_poly"><code class="docutils literal notranslate"><span class="pre">Design_Matrix.add_poly()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Design_Matrix.append"><code class="docutils literal notranslate"><span class="pre">Design_Matrix.append()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Design_Matrix.clean"><code class="docutils literal notranslate"><span class="pre">Design_Matrix.clean()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Design_Matrix.convolve"><code class="docutils literal notranslate"><span class="pre">Design_Matrix.convolve()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Design_Matrix.downsample"><code class="docutils literal notranslate"><span class="pre">Design_Matrix.downsample()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Design_Matrix.heatmap"><code class="docutils literal notranslate"><span class="pre">Design_Matrix.heatmap()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Design_Matrix.replace_data"><code class="docutils literal notranslate"><span class="pre">Design_Matrix.replace_data()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Design_Matrix.upsample"><code class="docutils literal notranslate"><span class="pre">Design_Matrix.upsample()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Design_Matrix.vif"><code class="docutils literal notranslate"><span class="pre">Design_Matrix.vif()</span></code></a></li>
<li><a class="reference internal" href="#nltools.data.Design_Matrix.zscore"><code class="docutils literal notranslate"><span class="pre">Design_Matrix.zscore()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#nltools-analysis-analysis-tools"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.analysis</span></code>: Analysis Tools</a><ul>
<li><a class="reference internal" href="#nltools.analysis.Roc"><code class="docutils literal notranslate"><span class="pre">Roc</span></code></a><ul>
<li><a class="reference internal" href="#nltools.analysis.Roc.calculate"><code class="docutils literal notranslate"><span class="pre">Roc.calculate()</span></code></a></li>
<li><a class="reference internal" href="#nltools.analysis.Roc.plot"><code class="docutils literal notranslate"><span class="pre">Roc.plot()</span></code></a></li>
<li><a class="reference internal" href="#nltools.analysis.Roc.summary"><code class="docutils literal notranslate"><span class="pre">Roc.summary()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-nltools.stats"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.stats</span></code>: Stats Tools</a><ul>
<li><a class="reference internal" href="#neurolearn-statistics-tools">NeuroLearn Statistics Tools</a></li>
<li><a class="reference internal" href="#nltools.stats.align"><code class="docutils literal notranslate"><span class="pre">align()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.align_states"><code class="docutils literal notranslate"><span class="pre">align_states()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.calc_bpm"><code class="docutils literal notranslate"><span class="pre">calc_bpm()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.correlation"><code class="docutils literal notranslate"><span class="pre">correlation()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.correlation_permutation"><code class="docutils literal notranslate"><span class="pre">correlation_permutation()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.distance_correlation"><code class="docutils literal notranslate"><span class="pre">distance_correlation()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.double_center"><code class="docutils literal notranslate"><span class="pre">double_center()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.downsample"><code class="docutils literal notranslate"><span class="pre">downsample()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.fdr"><code class="docutils literal notranslate"><span class="pre">fdr()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.find_spikes"><code class="docutils literal notranslate"><span class="pre">find_spikes()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.fisher_r_to_z"><code class="docutils literal notranslate"><span class="pre">fisher_r_to_z()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.fisher_z_to_r"><code class="docutils literal notranslate"><span class="pre">fisher_z_to_r()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.holm_bonf"><code class="docutils literal notranslate"><span class="pre">holm_bonf()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.isc"><code class="docutils literal notranslate"><span class="pre">isc()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.isc_group"><code class="docutils literal notranslate"><span class="pre">isc_group()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.isfc"><code class="docutils literal notranslate"><span class="pre">isfc()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.isps"><code class="docutils literal notranslate"><span class="pre">isps()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.make_cosine_basis"><code class="docutils literal notranslate"><span class="pre">make_cosine_basis()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.matrix_permutation"><code class="docutils literal notranslate"><span class="pre">matrix_permutation()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.multi_threshold"><code class="docutils literal notranslate"><span class="pre">multi_threshold()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.one_sample_permutation"><code class="docutils literal notranslate"><span class="pre">one_sample_permutation()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.pearson"><code class="docutils literal notranslate"><span class="pre">pearson()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.procrustes"><code class="docutils literal notranslate"><span class="pre">procrustes()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.procrustes_distance"><code class="docutils literal notranslate"><span class="pre">procrustes_distance()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.regress"><code class="docutils literal notranslate"><span class="pre">regress()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.summarize_bootstrap"><code class="docutils literal notranslate"><span class="pre">summarize_bootstrap()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.threshold"><code class="docutils literal notranslate"><span class="pre">threshold()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.transform_pairwise"><code class="docutils literal notranslate"><span class="pre">transform_pairwise()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.trim"><code class="docutils literal notranslate"><span class="pre">trim()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.two_sample_permutation"><code class="docutils literal notranslate"><span class="pre">two_sample_permutation()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.u_center"><code class="docutils literal notranslate"><span class="pre">u_center()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.upsample"><code class="docutils literal notranslate"><span class="pre">upsample()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.winsorize"><code class="docutils literal notranslate"><span class="pre">winsorize()</span></code></a></li>
<li><a class="reference internal" href="#nltools.stats.zscore"><code class="docutils literal notranslate"><span class="pre">zscore()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-nltools.datasets"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.datasets</span></code>: Dataset Tools</a><ul>
<li><a class="reference internal" href="#neurolearn-datasets">NeuroLearn datasets</a></li>
<li><a class="reference internal" href="#nltools.datasets.download_collection"><code class="docutils literal notranslate"><span class="pre">download_collection()</span></code></a></li>
<li><a class="reference internal" href="#nltools.datasets.download_nifti"><code class="docutils literal notranslate"><span class="pre">download_nifti()</span></code></a></li>
<li><a class="reference internal" href="#nltools.datasets.fetch_emotion_ratings"><code class="docutils literal notranslate"><span class="pre">fetch_emotion_ratings()</span></code></a></li>
<li><a class="reference internal" href="#nltools.datasets.fetch_pain"><code class="docutils literal notranslate"><span class="pre">fetch_pain()</span></code></a></li>
<li><a class="reference internal" href="#nltools.datasets.get_collection_image_metadata"><code class="docutils literal notranslate"><span class="pre">get_collection_image_metadata()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-nltools.cross_validation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.cross_validation</span></code>: Cross-Validation Tools</a><ul>
<li><a class="reference internal" href="#cross-validation-data-classes">Cross-Validation Data Classes</a></li>
<li><a class="reference internal" href="#nltools.cross_validation.KFoldStratified"><code class="docutils literal notranslate"><span class="pre">KFoldStratified</span></code></a><ul>
<li><a class="reference internal" href="#nltools.cross_validation.KFoldStratified.split"><code class="docutils literal notranslate"><span class="pre">KFoldStratified.split()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#nltools.cross_validation.set_cv"><code class="docutils literal notranslate"><span class="pre">set_cv()</span></code></a></li>
<li><a class="reference internal" href="#id0"><code class="docutils literal notranslate"><span class="pre">KFoldStratified</span></code></a><ul>
<li><a class="reference internal" href="#id3"><code class="docutils literal notranslate"><span class="pre">KFoldStratified.split()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-nltools.mask"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.mask</span></code>: Mask Tools</a><ul>
<li><a class="reference internal" href="#neurolearn-mask-classes">NeuroLearn Mask Classes</a></li>
<li><a class="reference internal" href="#nltools.mask.collapse_mask"><code class="docutils literal notranslate"><span class="pre">collapse_mask()</span></code></a></li>
<li><a class="reference internal" href="#nltools.mask.create_sphere"><code class="docutils literal notranslate"><span class="pre">create_sphere()</span></code></a></li>
<li><a class="reference internal" href="#nltools.mask.expand_mask"><code class="docutils literal notranslate"><span class="pre">expand_mask()</span></code></a></li>
<li><a class="reference internal" href="#nltools.mask.roi_to_brain"><code class="docutils literal notranslate"><span class="pre">roi_to_brain()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-nltools.file_reader"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.file_reader</span></code>: File Reading</a><ul>
<li><a class="reference internal" href="#neurolearn-file-reading-tools">NeuroLearn File Reading Tools</a></li>
<li><a class="reference internal" href="#nltools.file_reader.onsets_to_dm"><code class="docutils literal notranslate"><span class="pre">onsets_to_dm()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-nltools.utils"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.utils</span></code>: Utilities</a><ul>
<li><a class="reference internal" href="#neurolearn-utilities">NeuroLearn Utilities</a></li>
<li><a class="reference internal" href="#nltools.utils.concatenate"><code class="docutils literal notranslate"><span class="pre">concatenate()</span></code></a></li>
<li><a class="reference internal" href="#nltools.utils.get_anatomical"><code class="docutils literal notranslate"><span class="pre">get_anatomical()</span></code></a></li>
<li><a class="reference internal" href="#nltools.utils.get_resource_path"><code class="docutils literal notranslate"><span class="pre">get_resource_path()</span></code></a></li>
<li><a class="reference internal" href="#nltools.utils.set_algorithm"><code class="docutils literal notranslate"><span class="pre">set_algorithm()</span></code></a></li>
<li><a class="reference internal" href="#nltools.utils.set_decomposition_algorithm"><code class="docutils literal notranslate"><span class="pre">set_decomposition_algorithm()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#nltools-prefs-preferences"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.prefs</span></code>: Preferences</a><ul>
<li><a class="reference internal" href="#nltools.prefs.resolve_mni_path"><code class="docutils literal notranslate"><span class="pre">resolve_mni_path()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-nltools.plotting"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.plotting</span></code>: Plotting Tools</a><ul>
<li><a class="reference internal" href="#neurolearn-plotting-tools">NeuroLearn Plotting Tools</a></li>
<li><a class="reference internal" href="#nltools.plotting.dist_from_hyperplane_plot"><code class="docutils literal notranslate"><span class="pre">dist_from_hyperplane_plot()</span></code></a></li>
<li><a class="reference internal" href="#nltools.plotting.plot_between_label_distance"><code class="docutils literal notranslate"><span class="pre">plot_between_label_distance()</span></code></a></li>
<li><a class="reference internal" href="#nltools.plotting.plot_brain"><code class="docutils literal notranslate"><span class="pre">plot_brain()</span></code></a></li>
<li><a class="reference internal" href="#nltools.plotting.plot_interactive_brain"><code class="docutils literal notranslate"><span class="pre">plot_interactive_brain()</span></code></a></li>
<li><a class="reference internal" href="#nltools.plotting.plot_mean_label_distance"><code class="docutils literal notranslate"><span class="pre">plot_mean_label_distance()</span></code></a></li>
<li><a class="reference internal" href="#nltools.plotting.plot_silhouette"><code class="docutils literal notranslate"><span class="pre">plot_silhouette()</span></code></a></li>
<li><a class="reference internal" href="#nltools.plotting.plot_stacked_adjacency"><code class="docutils literal notranslate"><span class="pre">plot_stacked_adjacency()</span></code></a></li>
<li><a class="reference internal" href="#nltools.plotting.plot_t_brain"><code class="docutils literal notranslate"><span class="pre">plot_t_brain()</span></code></a></li>
<li><a class="reference internal" href="#nltools.plotting.probability_plot"><code class="docutils literal notranslate"><span class="pre">probability_plot()</span></code></a></li>
<li><a class="reference internal" href="#nltools.plotting.roc_plot"><code class="docutils literal notranslate"><span class="pre">roc_plot()</span></code></a></li>
<li><a class="reference internal" href="#nltools.plotting.scatterplot"><code class="docutils literal notranslate"><span class="pre">scatterplot()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-nltools.simulator"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.simulator</span></code>: Simulator Tools</a><ul>
<li><a class="reference internal" href="#neurolearn-simulator-tools">NeuroLearn Simulator Tools</a></li>
<li><a class="reference internal" href="#nltools.simulator.Simulator"><code class="docutils literal notranslate"><span class="pre">Simulator</span></code></a><ul>
<li><a class="reference internal" href="#nltools.simulator.Simulator.create_cov_data"><code class="docutils literal notranslate"><span class="pre">Simulator.create_cov_data()</span></code></a></li>
<li><a class="reference internal" href="#nltools.simulator.Simulator.create_data"><code class="docutils literal notranslate"><span class="pre">Simulator.create_data()</span></code></a></li>
<li><a class="reference internal" href="#nltools.simulator.Simulator.create_ncov_data"><code class="docutils literal notranslate"><span class="pre">Simulator.create_ncov_data()</span></code></a></li>
<li><a class="reference internal" href="#nltools.simulator.Simulator.gaussian"><code class="docutils literal notranslate"><span class="pre">Simulator.gaussian()</span></code></a></li>
<li><a class="reference internal" href="#nltools.simulator.Simulator.n_spheres"><code class="docutils literal notranslate"><span class="pre">Simulator.n_spheres()</span></code></a></li>
<li><a class="reference internal" href="#nltools.simulator.Simulator.normal_noise"><code class="docutils literal notranslate"><span class="pre">Simulator.normal_noise()</span></code></a></li>
<li><a class="reference internal" href="#nltools.simulator.Simulator.sphere"><code class="docutils literal notranslate"><span class="pre">Simulator.sphere()</span></code></a></li>
<li><a class="reference internal" href="#nltools.simulator.Simulator.to_nifti"><code class="docutils literal notranslate"><span class="pre">Simulator.to_nifti()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#index">Index</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <section id="api-reference">
<span id="api-ref"></span><h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this heading">¶</a></h1>
<p>This reference provides detailed documentation for all modules, classes, and
methods in the current release of Neurolearn.</p>
<section id="nltools-data-data-types">
<h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.data</span></code>: Data Types<a class="headerlink" href="#nltools-data-data-types" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="nltools.data.Brain_Data">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">nltools.data.</span></span><span class="sig-name descname"><span class="pre">Brain_Data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data" title="Permalink to this definition">¶</a></dt>
<dd><p>Brain_Data is a class to represent neuroimaging data in python as a vector
rather than a 3-dimensional matrix.This makes it easier to perform data
manipulation and analyses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – nibabel data instance or list of files</p></li>
<li><p><strong>Y</strong> – Pandas DataFrame of training labels</p></li>
<li><p><strong>X</strong> – Pandas DataFrame Design Matrix for running univariate models</p></li>
<li><p><strong>mask</strong> – binary nifiti file to mask brain data</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments to pass to the prediction
algorithm</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.aggregate">
<span class="sig-name descname"><span class="pre">aggregate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.aggregate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Create new Brain_Data instance that aggregages func over mask</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.align">
<span class="sig-name descname"><span class="pre">align</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'procrustes'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.align"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Align Brain_Data instance to target object using functional alignment</p>
<p>Alignment type can be hyperalignment or Shared Response Model. When
using hyperalignment, <cite>target</cite> image can be another subject or an
already estimated common model. When using SRM, <cite>target</cite> must be a previously
estimated common model stored as a numpy array. Transformed data can be back
projected to original data using Tranformation matrix.</p>
<p>See nltools.stats.align for aligning multiple Brain_Data instances</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> – (Brain_Data) object to align to.</p></li>
<li><p><strong>method</strong> – (str) alignment method to use
[‘probabilistic_srm’,’deterministic_srm’,’procrustes’]</p></li>
<li><p><strong>axis</strong> – (int) axis to align on</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(dict) a dictionary containing transformed object,</dt><dd><p>transformation matrix, and the shared response matrix</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<ul>
<li><dl>
<dt>Hyperalign using procrustes transform:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;procrustes&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl>
<dt>Align using shared response model:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;probabilistic_srm&#39;</span><span class="p">,</span> <span class="n">n_features</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl>
<dt>Project aligned data into original data:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; original_data = np.dot(out[‘transformed’].data,out[‘transformation_matrix’].T)
</pre></div>
</div>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.append"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append data to Brain_Data instance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – (Brain_Data) Brain_Data instance to append</p></li>
<li><p><strong>kwargs</strong> – optional inputs to Design_Matrix append</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(Brain_Data) new appended Brain_Data instance</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.apply_mask">
<span class="sig-name descname"><span class="pre">apply_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resample_mask_to_brain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.apply_mask"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.apply_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask Brain_Data instance</p>
<p>Note target data will be resampled into the same space as the mask. If you would like the mask
resampled into the Brain_Data space, then set resample_mask_to_brain=True.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mask</strong> – (Brain_Data or nifti object) mask to apply to Brain_Data object.</p></li>
<li><p><strong>resample_mask_to_brain</strong> – (bool) Will resample mask to brain space before applying mask (default=False).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(Brain_Data) masked Brain_Data object</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>masked</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.astype">
<span class="sig-name descname"><span class="pre">astype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.astype"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.astype" title="Permalink to this definition">¶</a></dt>
<dd><p>Cast Brain_Data.data as type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dtype</strong> – datatype to convert</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Brain_Data instance with new datatype</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#nltools.data.Brain_Data" title="nltools.data.Brain_Data">Brain_Data</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.bootstrap">
<span class="sig-name descname"><span class="pre">bootstrap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.bootstrap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.bootstrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bootstrap a <cite>Brain_Data</cite> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> – (str) method to apply to data for each bootstrap</p></li>
<li><p><strong>n_samples</strong> – (int) number of samples to bootstrap with replacement</p></li>
<li><p><strong>save_weights</strong> – (bool) Save each bootstrap iteration (useful for aggregating</p></li>
<li><p><strong>cluster</strong><strong>)</strong> (<em>many bootstraps on a</em>) – </p></li>
<li><p><strong>n_jobs</strong> – (int) The number of CPUs to use to do the computation. -1 means all</p></li>
<li><p><strong>CPUs.Returns</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>summarized studentized bootstrap output</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>output</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span> <span class="n">b</span> <span class="o">=</span> <span class="n">dat</span><span class="o">.</span><span class="n">bootstrap</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span> <span class="n">b</span> <span class="o">=</span> <span class="n">dat</span><span class="o">.</span><span class="n">bootstrap</span><span class="p">(</span><span class="s1">&#39;predict&#39;</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;ridge&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span> <span class="n">b</span> <span class="o">=</span> <span class="n">dat</span><span class="o">.</span><span class="n">bootstrap</span><span class="p">(</span><span class="s1">&#39;predict&#39;</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">save_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of a Brain_Data instance.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.decompose">
<span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pca'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'voxels'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_components</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.decompose"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.decompose" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompose Brain_Data object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>algorithm</strong> – (str) Algorithm to perform decomposition
types=[‘pca’,’ica’,’nnmf’,’fa’,’dictionary’,’kernelpca’]</p></li>
<li><p><strong>axis</strong> – dimension to decompose [‘voxels’,’images’]</p></li>
<li><p><strong>n_components</strong> – (int) number of components. If None then retain
as many as possible.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a dictionary of decomposition parameters</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>output</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.detrend">
<span class="sig-name descname"><span class="pre">detrend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.detrend"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.detrend" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove linear trend from each voxel</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>type</strong> – (‘linear’,’constant’, optional) type of detrending</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(Brain_Data) detrended Brain_Data instance</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.distance">
<span class="sig-name descname"><span class="pre">distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'euclidean'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate distance between images within a Brain_Data() instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>metric</strong> – (str) type of distance metric (can use any scikit learn or
sciypy metric)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(Adjacency) Outputs a 2D distance matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dist</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.dtype">
<span class="sig-name descname"><span class="pre">dtype</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.dtype"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Get data type of Brain_Data.data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.empty">
<span class="sig-name descname"><span class="pre">empty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.empty"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Initalize Brain_Data.data as empty</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.extract_roi">
<span class="sig-name descname"><span class="pre">extract_roi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_components</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.extract_roi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.extract_roi" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract activity from mask</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mask</strong> – (nifti) nibabel mask can be binary or numbered for
different rois</p></li>
<li><p><strong>metric</strong> – type of extraction method [‘mean’, ‘median’, ‘pca’], (default=mean)
NOTE: Only mean currently works!</p></li>
<li><p><strong>n_components</strong> – if metric=’pca’, number of components to return (takes any input into sklearn.Decomposition.PCA)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>mean within each ROI across images</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.filter">
<span class="sig-name descname"><span class="pre">filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling_freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.filter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply 5th order butterworth filter to data. Wraps nilearn
functionality. Does not default to detrending and standardizing like
nilearn implementation, but this can be overridden using kwargs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sampling_freq</strong> – sampling freq in hertz (i.e. 1 / TR)</p></li>
<li><p><strong>high_pass</strong> – high pass cutoff frequency</p></li>
<li><p><strong>low_pass</strong> – low pass cutoff frequency</p></li>
<li><p><strong>kwargs</strong> – other keyword arguments to nilearn.signal.clean</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Filtered Brain_Data instance</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#nltools.data.Brain_Data" title="nltools.data.Brain_Data">Brain_Data</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.find_spikes">
<span class="sig-name descname"><span class="pre">find_spikes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">global_spike_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diff_spike_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.find_spikes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.find_spikes" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to identify spikes from Time Series Data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>global_spike_cutoff</strong> – (int,None) cutoff to identify spikes in global signal
in standard deviations, None indicates do not calculate.</p></li>
<li><p><strong>diff_spike_cutoff</strong> – (int,None) cutoff to identify spikes in average frame difference
in standard deviations, None indicates do not calculate.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pandas dataframe with spikes as indicator variables</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.groupby">
<span class="sig-name descname"><span class="pre">groupby</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.groupby"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.groupby" title="Permalink to this definition">¶</a></dt>
<dd><p>Create groupby instance</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.icc">
<span class="sig-name descname"><span class="pre">icc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">icc_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'icc2'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.icc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.icc" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Calculate intraclass correlation coefficient for data within</dt><dd><p>Brain_Data class</p>
</dd>
</dl>
<p>ICC Formulas are based on:
Shrout, P. E., &amp; Fleiss, J. L. (1979). Intraclass correlations: uses in
assessing rater reliability. Psychological bulletin, 86(2), 420.</p>
<p>icc1:  x_ij = mu + beta_j + w_ij
icc2/3:  x_ij = mu + alpha_i + beta_j + (ab)_ij + epsilon_ij</p>
<p>Code modifed from nipype algorithms.icc
<a class="reference external" href="https://github.com/nipy/nipype/blob/master/nipype/algorithms/icc.py">https://github.com/nipy/nipype/blob/master/nipype/algorithms/icc.py</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>icc_type</strong> – type of icc to calculate (icc: voxel random effect,
icc2: voxel and column random effect, icc3: voxel and
column fixed effect)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(np.array) intraclass correlation coefficient</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ICC</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.iplot">
<span class="sig-name descname"><span class="pre">iplot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anatomical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.iplot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.iplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an interactive brain viewer for the current brain data instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>threshold</strong> – (float/str) two-sided threshold to initialize the
visualization, maybe be a percentile string; default 0</p></li>
<li><p><strong>surface</strong> – (bool) whether to create a surface-based plot; default False</p></li>
<li><p><strong>anatomical</strong> – nifti image or filename to overlay</p></li>
<li><p><strong>kwargs</strong> – optional arguments to nilearn.view_img or
nilearn.view_img_on_surf</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>interactive brain viewer widget</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.isempty">
<span class="sig-name descname"><span class="pre">isempty</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.isempty"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.isempty" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if Brain_Data.data is empty</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.mean">
<span class="sig-name descname"><span class="pre">mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.mean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Get mean of each voxel or image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>axis</strong> – (int) across images=0 (default), within images=1</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(float/np.array/Brain_Data)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.median">
<span class="sig-name descname"><span class="pre">median</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.median"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.median" title="Permalink to this definition">¶</a></dt>
<dd><p>Get median of each voxel or image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>axis</strong> – (int) across images=0 (default), within images=1</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(float/np.array/Brain_Data)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.multivariate_similarity">
<span class="sig-name descname"><span class="pre">multivariate_similarity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">images</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ols'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.multivariate_similarity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.multivariate_similarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict spatial distribution of Brain_Data() instance from linear
combination of other Brain_Data() instances or Nibabel images</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>self</strong> – Brain_Data instance of data to be applied</p></li>
<li><p><strong>images</strong> – Brain_Data instance of weight map</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>dictionary of regression statistics in Brain_Data</dt><dd><p>instances {‘beta’,’t’,’p’,’df’,’residual’}</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anatomical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'axial'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">black_bg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">draw_cross</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(15,</span> <span class="pre">2)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a quick plot of self.data.  Will plot each image separately</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>limit</strong> – (int) max number of images to return</p></li>
<li><p><strong>anatomical</strong> – (nifti, str) nifti image or file name to overlay</p></li>
<li><p><strong>view</strong> – (str) ‘axial’ for limit number of axial slices;
‘glass’ for ortho-view glass brain; ‘mni’ for
multi-slice view mni brain; ‘full’ for both glass and
mni views</p></li>
<li><p><strong>threshold_upper</strong> – (str/float) threshold if view is ‘glass’,
‘mni’, or ‘full’</p></li>
<li><p><strong>threshold_lower</strong> – (str/float)threshold if view is ‘glass’,
‘mni’, or ‘full’</p></li>
<li><p><strong>save</strong> – (str/bool): optional string file name or path for saving; only applies if view is ‘mni’, ‘glass’, or ‘full’.
Filenames will appended with the orientation they belong to</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cv_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Run prediction</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>algorithm</strong> – Algorithm to use for prediction.  Must be one of ‘svm’,
‘svr’, ‘linear’, ‘logistic’, ‘lasso’, ‘ridge’,
‘ridgeClassifier’,’pcr’, or ‘lassopcr’</p></li>
<li><p><strong>cv_dict</strong> – Type of cross_validation to use. A dictionary of
{‘type’: ‘kfolds’, ‘n_folds’: n},
{‘type’: ‘kfolds’, ‘n_folds’: n, ‘stratified’: Y},
{‘type’: ‘kfolds’, ‘n_folds’: n, ‘subject_id’: holdout}, or
{‘type’: ‘loso’, ‘subject_id’: holdout}
where ‘n’ = number of folds, and ‘holdout’ = vector of
subject ids that corresponds to self.Y</p></li>
<li><p><strong>plot</strong> – Boolean indicating whether or not to create plots.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – print performance; Default True</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments to pass to the prediction
algorithm</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a dictionary of prediction parameters</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>output</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.predict_multi">
<span class="sig-name descname"><span class="pre">predict_multi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cv_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'searchlight'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rois</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">process_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scoring</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.predict_multi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.predict_multi" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform multi-region prediction. This can be a searchlight analysis or multi-roi analysis if provided a Brain_Data instance with labeled non-overlapping rois.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>algorithm</strong> (<em>string</em>) – algorithm to use for prediction Must be one of ‘svm’,
‘svr’, ‘linear’, ‘logistic’, ‘lasso’, ‘ridge’,
‘ridgeClassifier’,’pcr’, or ‘lassopcr’</p></li>
<li><p><strong>cv_dict</strong> – Type of cross_validation to use. Default is 3-fold. A dictionary of
{‘type’: ‘kfolds’, ‘n_folds’: n},
{‘type’: ‘kfolds’, ‘n_folds’: n, ‘stratified’: Y},
{‘type’: ‘kfolds’, ‘n_folds’: n, ‘subject_id’: holdout}, or
{‘type’: ‘loso’, ‘subject_id’: holdout}
where ‘n’ = number of folds, and ‘holdout’ = vector of
subject ids that corresponds to self.Y</p></li>
<li><p><strong>method</strong> (<em>string</em>) – one of ‘searchlight’ or ‘roi’</p></li>
<li><p><strong>rois</strong> (<em>string/nltools.Brain_Data</em>) – nifti file path or Brain_data instance containing non-overlapping regions-of-interest labeled by integers</p></li>
<li><p><strong>process_mask</strong> (<em>nib.Nifti1Image/nltools.Brain_Data</em>) – mask to constrain where to perform analyses; only applied if method = ‘searchlight’</p></li>
<li><p><strong>radius</strong> (<em>float</em>) – radius of searchlight in mm; default 2mm</p></li>
<li><p><strong>scoring</strong> (<em>function</em>) – callable scoring function; see sklearn documentation; defaults to estimator’s default scoring function</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of CPUs to use to do permutation; default 1 because this can be very memory intensive</p></li>
<li><p><strong>verbose</strong> (<em>int</em>) – whether parallelization progress should be printed; default 0</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>image of results</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>output</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.r_to_z">
<span class="sig-name descname"><span class="pre">r_to_z</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.r_to_z"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.r_to_z" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply Fisher’s r to z transformation to each element of the data
object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.randomise">
<span class="sig-name descname"><span class="pre">randomise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.randomise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.randomise" title="Permalink to this definition">¶</a></dt>
<dd><p>Run mass-univariate regression at each voxel with inference performed
via permutation testing ala randomise in FSL. Operates just like
.regress(), but intended to be used for second-level analyses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_permute</strong> (<em>int</em>) – number of permutations</p></li>
<li><p><strong>threshold_dict</strong> – (dict) a dictionary of threshold parameters
{‘unc’:.001} or {‘fdr’:.05}</p></li>
<li><p><strong>return_mask</strong> – (bool) optionally return the thresholding mask</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>dictionary of maps for betas, tstats, and pvalues</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.regions">
<span class="sig-name descname"><span class="pre">regions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_region_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1350</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extract_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'local_regions'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing_fwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.regions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract brain connected regions into separate regions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>min_region_size</strong> (<em>int</em>) – Minimum volume in mm3 for a region to be
kept.</p></li>
<li><p><strong>extract_type</strong> (<em>str</em>) – Type of extraction method
[‘connected_components’, ‘local_regions’].
If ‘connected_components’, each component/region
in the image is extracted automatically by
labelling each region based upon the presence of
unique features in their respective regions.
If ‘local_regions’, each component/region is
extracted based on their maximum peak value to
define a seed marker and then using random
walker segementation algorithm on these
markers for region separation.</p></li>
<li><p><strong>smoothing_fwhm</strong> (<em>scalar</em>) – Smooth an image to extract more sparser
regions. Only works for extract_type
‘local_regions’.</p></li>
<li><p><strong>is_mask</strong> (<em>bool</em>) – Whether the Brain_Data instance should be treated
as a boolean mask and if so, calls
connected_label_regions instead.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Brain_Data instance with extracted ROIs as data.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#nltools.data.Brain_Data" title="nltools.data.Brain_Data">Brain_Data</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.regress">
<span class="sig-name descname"><span class="pre">regress</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ols'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.regress"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.regress" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a mass-univariate regression across voxels. Three types of regressions can be run:
1) Standard OLS (default)
2) Robust OLS (heteroscedasticty and/or auto-correlation robust errors), i.e. OLS with “sandwich estimators”
3) ARMA (auto-regressive and moving-average lags = 1 by default; experimental)</p>
<p>For more information see the help for nltools.stats.regress</p>
<p>ARMA notes: This experimental mode is similar to AFNI’s 3dREMLFit but without spatial smoothing of voxel auto-correlation estimates. It can be <strong>very computationally intensive</strong> so parallelization is used by default to try to speed things up. Speed is limited because a unique ARMA model is fit to <em>each voxel</em> (like AFNI/FSL), but unlike SPM, which assumes the same AR parameters (~0.2) at each voxel. While coefficient results are typically very similar to OLS, std-errors and so t-stats, dfs and and p-vals can differ greatly depending on how much auto-correlation is explaining the response in a voxel
relative to other regressors in the design matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mode</strong> (<em>str</em>) – kind of model to fit; must be one of ‘ols’ (default), ‘robust’, or ‘arma’</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – keyword arguments to nltools.stats.regress</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>dictionary of regression statistics in Brain_Data instances</dt><dd><p>{‘beta’,’t’,’p’,’df’,’residual’}</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.scale">
<span class="sig-name descname"><span class="pre">scale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scale_val</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.scale"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.scale" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Scale all values such that they are on the range [0, scale_val],</dt><dd><p>via grand-mean scaling. This is NOT global-scaling/intensity
normalization. This is useful for ensuring that data is on a
common scale (e.g. good for multiple runs, participants, etc)
and if the default value of 100 is used, can be interpreted as
something akin to (but not exactly) “percent signal change.”
This is consistent with default behavior in AFNI and SPM.
Change this value to 10000 to make consistent with FSL.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>scale_val</strong> – (int/float) what value to send the grand-mean to;
default 100</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.shape">
<span class="sig-name descname"><span class="pre">shape</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Get images by voxels shape.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.similarity">
<span class="sig-name descname"><span class="pre">similarity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'correlation'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.similarity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.similarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate similarity of Brain_Data() instance with single
Brain_Data or Nibabel image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> – (Brain_Data, nifti)  image to evaluate similarity</p></li>
<li><p><strong>method</strong> – (str) Type of similarity
[‘correlation’,’dot_product’,’cosine’]</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(list) Outputs a vector of pattern expression values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pexp</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.smooth">
<span class="sig-name descname"><span class="pre">smooth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fwhm</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.smooth"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply spatial smoothing using nilearn smooth_img()</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>fwhm</strong> – (float) full width half maximum of gaussian spatial filter</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Brain_Data instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.standardize">
<span class="sig-name descname"><span class="pre">standardize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'center'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.standardize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.standardize" title="Permalink to this definition">¶</a></dt>
<dd><p>Standardize Brain_Data() instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> – 0 for observations 1 for voxels</p></li>
<li><p><strong>method</strong> – [‘center’,’zscore’]</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Brain_Data Instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.std">
<span class="sig-name descname"><span class="pre">std</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.std"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Get standard deviation of each voxel or image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>axis</strong> – (int) across images=0 (default), within images=1</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(float/np.array/Brain_Data)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.sum">
<span class="sig-name descname"><span class="pre">sum</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.sum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum over voxels.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.temporal_resample">
<span class="sig-name descname"><span class="pre">temporal_resample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling_freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hz'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.temporal_resample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.temporal_resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample Brain_Data timeseries to a new target frequency or number of samples
using Piecewise Cubic Hermite Interpolating Polynomial (PCHIP) interpolation.
This function can up- or down-sample data.</p>
<p>Note: this function can use quite a bit of RAM.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sampling_freq</strong> – (float) sampling frequency of data in hertz</p></li>
<li><p><strong>target</strong> – (float) upsampling target</p></li>
<li><p><strong>target_type</strong> – (str) type of target can be [samples,seconds,hz]</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>upsampled Brain_Data instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.threshold">
<span class="sig-name descname"><span class="pre">threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">binarize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coerce_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.threshold"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.threshold" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Threshold Brain_Data instance. Provide upper and lower values or</dt><dd><p>percentages to perform two-sided thresholding. Binarize will return
a mask image respecting thresholds if provided, otherwise respecting
every non-zero value.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>upper</strong> – (float or str) Upper cutoff for thresholding. If string
will interpret as percentile; can be None for one-sided
thresholding.</p></li>
<li><p><strong>lower</strong> – (float or str) Lower cutoff for thresholding. If string
will interpret as percentile; can be None for one-sided
thresholding.</p></li>
<li><p><strong>binarize</strong> (<em>bool</em>) – return binarized image respecting thresholds if
provided, otherwise binarize on every non-zero value;
default False</p></li>
<li><p><strong>coerce_nan</strong> (<em>bool</em>) – coerce nan values to 0s; default True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Thresholded Brain_Data object.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.to_nifti">
<span class="sig-name descname"><span class="pre">to_nifti</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.to_nifti"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.to_nifti" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Brain_Data Instance into Nifti Object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.transform_pairwise">
<span class="sig-name descname"><span class="pre">transform_pairwise</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.transform_pairwise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.transform_pairwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract brain connected regions into separate regions.</p>
<p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Brain_Data instance tranformed into pairwise comparisons</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#nltools.data.Brain_Data" title="nltools.data.Brain_Data">Brain_Data</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.ttest">
<span class="sig-name descname"><span class="pre">ttest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.ttest"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.ttest" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate one sample t-test across each voxel (two-sided)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>threshold_dict</strong> – (dict) a dictionary of threshold parameters
{‘unc’:.001} or {‘fdr’:.05}</p></li>
<li><p><strong>return_mask</strong> – (bool) if thresholding is requested, optionall return the mask of voxels that exceed threshold, e.g. for use with another map</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(dict) dictionary of regression statistics in Brain_Data</dt><dd><p>instances {‘t’,’p’}</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.upload_neurovault">
<span class="sig-name descname"><span class="pre">upload_neurovault</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">access_token</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collection_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collection_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img_modality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.upload_neurovault"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.upload_neurovault" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Upload Data to Neurovault.  Will add any columns in self.X to image</dt><dd><p>metadata. Index will be used as image name.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>access_token</strong> – (str, Required) Neurovault api access token</p></li>
<li><p><strong>collection_name</strong> – (str, Optional) name of new collection to create</p></li>
<li><p><strong>collection_id</strong> – (int, Optional) neurovault collection_id if adding images
to existing collection</p></li>
<li><p><strong>img_type</strong> – (str, Required) Neurovault map_type</p></li>
<li><p><strong>img_modality</strong> – (str, Required) Neurovault image modality</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(pd.DataFrame) neurovault collection information</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>collection</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.write"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write out Brain_Data object to Nifti or HDF5 File.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>file_name</strong> – (str) name of nifti file including path</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Brain_Data.z_to_r">
<span class="sig-name descname"><span class="pre">z_to_r</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.z_to_r"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.z_to_r" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert z score back into r value for each element of data object</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="nltools.data.Adjacency">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">nltools.data.</span></span><span class="sig-name descname"><span class="pre">Adjacency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjacency is a class to represent Adjacency matrices as a vector rather
than a 2-dimensional matrix. This makes it easier to perform data
manipulation and analyses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – pandas data instance or list of files</p></li>
<li><p><strong>matrix_type</strong> – (str) type of matrix.  Possible values include:
[‘distance’,’similarity’,’directed’,’distance_flat’,
‘similarity_flat’,’directed_flat’]</p></li>
<li><p><strong>Y</strong> – Pandas DataFrame of training labels</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.append"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append data to Adjacency instance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> – (Adjacency) Adjacency instance to append</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(Adjacency) new appended Adjacency instance</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.bootstrap">
<span class="sig-name descname"><span class="pre">bootstrap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.bootstrap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.bootstrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bootstrap an Adjacency method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> – (str) method to apply to data for each bootstrap</p></li>
<li><p><strong>n_samples</strong> – (int) number of samples to bootstrap with replacement</p></li>
<li><p><strong>save_weights</strong> – (bool) Save each bootstrap iteration
(useful for aggregating many bootstraps on a cluster)</p></li>
<li><p><strong>n_jobs</strong> – (int) The number of CPUs to use to do the computation.
-1 means all CPUs.Returns:</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>summarized studentized bootstrap output</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span> <span class="n">b</span> <span class="o">=</span> <span class="n">dat</span><span class="o">.</span><span class="n">bootstrap</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span> <span class="n">b</span> <span class="o">=</span> <span class="n">dat</span><span class="o">.</span><span class="n">bootstrap</span><span class="p">(</span><span class="s1">&#39;predict&#39;</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;ridge&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span> <span class="n">b</span> <span class="o">=</span> <span class="n">dat</span><span class="o">.</span><span class="n">bootstrap</span><span class="p">(</span><span class="s1">&#39;predict&#39;</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">save_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.cluster_summary">
<span class="sig-name descname"><span class="pre">cluster_summary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clusters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">summary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'within'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.cluster_summary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.cluster_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>This function provides summaries of clusters within Adjacency matrices.</p>
<p>It can compute mean/median of within and between cluster values. Requires a
list of cluster ids indicating the row/column of each cluster.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clusters</strong> – (list) list of cluster labels</p></li>
<li><p><strong>metric</strong> – (str) method to summarize mean or median. If ‘None” then return all r values</p></li>
<li><p><strong>summary</strong> – (str) summarize within cluster or between clusters</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(dict) within cluster means</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of Adjacency object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.distance">
<span class="sig-name descname"><span class="pre">distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'correlation'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate distance between images within an Adjacency() instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>metric</strong> – (str) type of distance metric (can use any scikit learn or
sciypy metric)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(Adjacency) Outputs a 2D distance matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dist</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.distance_to_similarity">
<span class="sig-name descname"><span class="pre">distance_to_similarity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'correlation'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.distance_to_similarity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.distance_to_similarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert distance matrix to similarity matrix.</p>
<p>Note: currently only implemented for correlation and euclidean.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>metric</strong> – (str) Can only be correlation or euclidean</p></li>
<li><p><strong>beta</strong> – (float) parameter to scale exponential function (default: 1) for euclidean</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(Adjacency) Adjacency object</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.generate_permutations">
<span class="sig-name descname"><span class="pre">generate_permutations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_perm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.generate_permutations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.generate_permutations" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate n_perm permutated versions of Adjacency in a lazy fashion. Useful for iterating against.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_perm</strong> (<em>int</em>) – number of permutations</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>np.random.seed</em><em>, </em><em>optional</em>) – random seed for reproducibility. Defaults to None.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">adj</span><span class="o">.</span><span class="n">generate_permutations</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">out</span> <span class="o">=</span> <span class="n">neural_distance_mat</span><span class="o">.</span><span class="n">similarity</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="o">...</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Yields<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Adjacency</em> – permuted version of self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.isc">
<span class="sig-name descname"><span class="pre">isc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'median'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci_percentile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_self_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_null</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.isc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.isc" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute intersubject correlation.</p>
<p>This implementation uses the subject-wise bootstrap method from Chen et al., 2016.
Instead of recomputing the pairwise ISC using circle_shift or phase_randomization methods,
this approach uses the computationally more efficient method of bootstrapping the subjects
and computing a new pairwise similarity matrix with randomly selected subjects with replacement.
If the same subject is selected multiple times, we set the perfect correlation to a nan with
(exclude_self_corr=True). As recommended by Chen et al., 2016, we compute the median pairwise ISC
by default. However, if the mean is preferred, we compute the mean correlation after performing
the fisher r-to-z transformation and then convert back to correlations to minimize artificially
inflating the correlation values. We compute the p-values using the percentile method using the same
method in Brainiak.</p>
<p>Chen, G., Shin, Y. W., Taylor, P. A., Glen, D. R., Reynolds, R. C., Israel, R. B.,
&amp; Cox, R. W. (2016). Untangling the relatedness among correlations, part I:
nonparametric approaches to inter-subject correlation analysis at the group level.
NeuroImage, 142, 248-259.</p>
<p>Hall, P., &amp; Wilson, S. R. (1991). Two guidelines for bootstrap hypothesis testing.
Biometrics, 757-762.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_bootstraps</strong> – (int) number of bootstraps</p></li>
<li><p><strong>metric</strong> – (str) type of association metric [‘spearman’,’pearson’,’kendall’]</p></li>
<li><p><strong>tail</strong> – (int) either 1 for one-tail or 2 for two-tailed test (default: 2)</p></li>
<li><p><strong>n_jobs</strong> – (int) The number of CPUs to use to do the computation. -1 means all CPUs.</p></li>
<li><p><strong>return_parms</strong> – (bool) Return the permutation distribution along with the p-value; default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(dict) dictionary of permutation results [‘correlation’,’p’]</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>stats</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.isc_group">
<span class="sig-name descname"><span class="pre">isc_group</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'median'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'permute'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci_percentile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_self_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_null</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.isc_group"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.isc_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute intersubject correlation differences between groups.</p>
<blockquote>
<div><p>This function computes pairwise intersubject correlations (ISC) using the median as recommended by Chen
et al., 2016). However, if the mean is preferred, we compute the mean correlation after performing
the fisher r-to-z transformation and then convert back to correlations to minimize artificially
inflating the correlation values.</p>
<p>There are currently two different methods to compute p-values. By default, we use the subject-wise permutation
method recommended Chen et al., 2016. This method combines the two groups and computes pairwise similarity both
within and between the groups. Then the group labels are permuted and the mean difference between the two groups
are recomputed to generate a null distribution. The second method uses subject-wise bootstrapping, where a new
pairwise similarity matrix with randomly selected subjects with replacement is created separately for each group
and the ISC difference between these groups is used to generate a null distribution. If the same subject is
selected multiple times, we set the perfect correlation to a nan with (exclude_self_corr=True). We compute the
p-values using the percentile method (Hall &amp; Wilson, 1991).</p>
<p>Chen, G., Shin, Y. W., Taylor, P. A., Glen, D. R., Reynolds, R. C., Israel, R. B.,
&amp; Cox, R. W. (2016). Untangling the relatedness among correlations, part I:
nonparametric approaches to inter-subject correlation analysis at the group level.
NeuroImage, 142, 248-259.</p>
<p>Hall, P., &amp; Wilson, S. R. (1991). Two guidelines for bootstrap hypothesis testing.
Biometrics, 757-762.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> – (np.array) vector of group ids corresponding to subject data in Adjacency instance</p></li>
<li><p><strong>n_samples</strong> – (int) number of samples for permutation or bootstrapping</p></li>
<li><p><strong>metric</strong> – (str) type of isc summary metric [‘mean’,’median’]</p></li>
<li><p><strong>method</strong> – (str) method to compute p-values [‘permute’, ‘bootstrap’] (default: permute)</p></li>
<li><p><strong>tail</strong> – (int) either 1 for one-tail or 2 for two-tailed test (default: 2)</p></li>
<li><p><strong>n_jobs</strong> – (int) The number of CPUs to use to do the computation. -1 means all CPUs.</p></li>
<li><p><strong>return_null</strong> – (bool) Return the permutation distribution along with the p-value; default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(dict) dictionary of permutation results [‘correlation’,’p’]</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>stats</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.isempty">
<span class="sig-name descname"><span class="pre">isempty</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.isempty"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.isempty" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if Adjacency object is empty</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.mean">
<span class="sig-name descname"><span class="pre">mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.mean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate mean of Adjacency</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>axis</strong> – (int) calculate mean over features (0) or data (1).
For data it will be on upper triangle.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>float if single, adjacency if axis=0, np.array if axis=1</dt><dd><p>and multiple</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>mean</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.median">
<span class="sig-name descname"><span class="pre">median</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.median"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.median" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate median of Adjacency</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>axis</strong> – (int) calculate median over features (0) or data (1).
For data it will be on upper triangle.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>float if single, adjacency if axis=0, np.array if axis=1</dt><dd><p>and multiple</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>mean</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Heatmap of Adjacency Matrix</p>
<p>Can pass in any sns.heatmap argument</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>limit</strong> – (int) number of heatmaps to plot if object contains multiple adjacencies (default: 3)</p></li>
<li><p><strong>axes</strong> – matplotlib axis handle</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.plot_label_distance">
<span class="sig-name descname"><span class="pre">plot_label_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.plot_label_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.plot_label_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a violin plot indicating within and between label distance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>labels</strong> (<em>np.array</em>) – numpy array of labels to plot</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>violin plot handles</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>f</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.plot_mds">
<span class="sig-name descname"><span class="pre">plot_mds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">n_components=2,</span> <span class="pre">metric=True,</span> <span class="pre">labels=None,</span> <span class="pre">labels_color=None,</span> <span class="pre">cmap=&lt;matplotlib.colors.LinearSegmentedColormap</span> <span class="pre">object&gt;,</span> <span class="pre">n_jobs=-1,</span> <span class="pre">view=(30,</span> <span class="pre">20),</span> <span class="pre">figsize=[12,</span> <span class="pre">8],</span> <span class="pre">ax=None,</span> <span class="pre">*args,</span> <span class="pre">**kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.plot_mds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.plot_mds" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot Multidimensional Scaling</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_components</strong> – (int) Number of dimensions to project (can be 2 or 3)</p></li>
<li><p><strong>metric</strong> – (bool) Perform metric or non-metric dimensional scaling; default</p></li>
<li><p><strong>labels</strong> – (list) Can override labels stored in Adjacency Class</p></li>
<li><p><strong>labels_color</strong> – (str) list of colors for labels, if len(1) then make all same color</p></li>
<li><p><strong>n_jobs</strong> – (int) Number of parallel jobs</p></li>
<li><p><strong>view</strong> – (tuple) view for 3-Dimensional plot; default (30,20)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.plot_silhouette">
<span class="sig-name descname"><span class="pre">plot_silhouette</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permutation_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.plot_silhouette"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.plot_silhouette" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a silhouette plot</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.r_to_z">
<span class="sig-name descname"><span class="pre">r_to_z</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.r_to_z"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.r_to_z" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply Fisher’s r to z transformation to each element of the data
object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.regress">
<span class="sig-name descname"><span class="pre">regress</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ols'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.regress"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.regress" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a regression on an adjacency instance.
You can decompose an adjacency instance with another adjacency instance.
You can also decompose each pixel by passing a design_matrix instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> – Design matrix can be an Adjacency or Design_Matrix instance</p></li>
<li><p><strong>method</strong> – type of regression (default: ols)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(dict) dictionary of stats outputs.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>stats</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.shape">
<span class="sig-name descname"><span class="pre">shape</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate shape of data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.similarity">
<span class="sig-name descname"><span class="pre">similarity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perm_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2d'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'spearman'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_diagonal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.similarity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.similarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate similarity between two Adjacency matrices. Default is to use spearman
correlation and permutation test.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<a class="reference internal" href="#nltools.data.Adjacency" title="nltools.data.Adjacency"><em>Adjacency</em></a><em> or </em><em>array</em>) – Adjacency data, or 1-d array same size as self.data</p></li>
<li><p><strong>perm_type</strong> – (str) ‘1d’,’2d’, or None</p></li>
<li><p><strong>metric</strong> – (str) ‘spearman’,’pearson’,’kendall’</p></li>
<li><p><strong>ignore_diagonal</strong> – (bool) only applies to ‘directed’ Adjacency types using</p></li>
<li><p><strong>perm_type='1d'</strong> (<em>perm_type=None or</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.social_relations_model">
<span class="sig-name descname"><span class="pre">social_relations_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">summarize_results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nan_replace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.social_relations_model"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.social_relations_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the social relations model from a matrix for a round-robin design.</p>
<p>X_{ij} = m + lpha_i + eta_j + g_{ij} + epsilon_{ijl}</p>
<p>where X_{ij} is the score for person i rating person j, m is the group mean,
lpha_i  is person i’s actor effect, eta_j is person j’s partner effect, g_{ij}
is the relationship  effect and epsilon_{ijl} is the error in measure l  for actor i and partner j.</p>
<p>This model is primarily concerned with partioning the variance of the various effects.</p>
<p>Code is based on implementation presented in Chapter 8 of Kenny, Kashy, &amp; Cook (2006).
Tests replicate examples  presented in the book. Note, that this method assumes that
actor scores are rows (lower triangle), while partner scores are columnns (upper triangle).
The minimal sample size to estimate these effects is 4.</p>
<dl class="simple">
<dt>Model Assumptions:</dt><dd><ul class="simple">
<li><p>Social interactions are exclusively dyadic</p></li>
<li><p>People are randomly sampled from population</p></li>
<li><p>No order effects</p></li>
<li><p>The effects combine additively and relationships are linear</p></li>
</ul>
</dd>
</dl>
<p>In the future we might update the formulas and standard errors based on
Bond and Lashley, 1996</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>self</strong> – (adjacency) can be a single matrix or many matrices for each group</p></li>
<li><p><strong>summarize_results</strong> – (bool) will provide a formatted summary of model results</p></li>
<li><p><strong>nan_replace</strong> – (bool) will replace nan values with row and column means</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(pd.Series/pd.DataFrame) All of the effects estimated using SRM</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>estimated effects</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.square_shape">
<span class="sig-name descname"><span class="pre">square_shape</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.square_shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.square_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate shape of squareform data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.squareform">
<span class="sig-name descname"><span class="pre">squareform</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.squareform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.squareform" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert adjacency back to squareform</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.stats_label_distance">
<span class="sig-name descname"><span class="pre">stats_label_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.stats_label_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.stats_label_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate permutation tests on within and between label distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>labels</strong> (<em>np.array</em>) – numpy array of labels to plot</p></li>
<li><p><strong>n_permute</strong> (<em>int</em>) – number of permutations to run (default=5000)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>dictionary of within and between group differences</dt><dd><p>and p-values</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.std">
<span class="sig-name descname"><span class="pre">std</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.std"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate standard deviation of Adjacency</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>axis</strong> – (int) calculate std over features (0) or data (1).
For data it will be on upper triangle.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>float if single, adjacency if axis=0, np.array if axis=1 and</dt><dd><p>multiple</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>std</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.sum">
<span class="sig-name descname"><span class="pre">sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.sum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate sum of Adjacency</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>axis</strong> – (int) calculate mean over features (0) or data (1).
For data it will be on upper triangle.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>float if single, adjacency if axis=0, np.array if axis=1</dt><dd><p>and multiple</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>mean</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.threshold">
<span class="sig-name descname"><span class="pre">threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">binarize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.threshold"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.threshold" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Threshold Adjacency instance. Provide upper and lower values or</dt><dd><p>percentages to perform two-sided thresholding. Binarize will return
a mask image respecting thresholds if provided, otherwise respecting
every non-zero value.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>upper</strong> – (float or str) Upper cutoff for thresholding. If string
will interpret as percentile; can be None for one-sided
thresholding.</p></li>
<li><p><strong>lower</strong> – (float or str) Lower cutoff for thresholding. If string
will interpret as percentile; can be None for one-sided
thresholding.</p></li>
<li><p><strong>binarize</strong> (<em>bool</em>) – return binarized image respecting thresholds if
provided, otherwise binarize on every non-zero value;
default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>thresholded Adjacency instance</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#nltools.data.Adjacency" title="nltools.data.Adjacency">Adjacency</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.to_graph">
<span class="sig-name descname"><span class="pre">to_graph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.to_graph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.to_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Adjacency into networkx graph.  only works on
single_matrix for now.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.ttest">
<span class="sig-name descname"><span class="pre">ttest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">permutation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.ttest"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.ttest" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate ttest across samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>permutation</strong> – (bool) Run ttest as permutation. Note this can be very slow.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(dict) contains Adjacency instances of t values (or mean if</dt><dd><p>running permutation) and Adjacency instance of p values.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'long'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.write"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write out Adjacency object to csv file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_name</strong> (<em>str</em>) – name of file name to write</p></li>
<li><p><strong>method</strong> (<em>str</em>) – method to write out data [‘long’,’square’]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Adjacency.z_to_r">
<span class="sig-name descname"><span class="pre">z_to_r</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.z_to_r"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.z_to_r" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert z score back into r value for each element of data object</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="nltools.data.Groupby">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">nltools.data.</span></span><span class="sig-name descname"><span class="pre">Groupby</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Groupby"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Groupby" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Groupby.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Groupby.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Groupby.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply Brain_Data instance methods to each element of Groupby
object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Groupby.combine">
<span class="sig-name descname"><span class="pre">combine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value_dict</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Groupby.combine"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Groupby.combine" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine value dictionary back into masks</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Groupby.split">
<span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Groupby.split"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Groupby.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split Brain_Data instance into separate masks and store as a
dictionary.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="nltools.data.Design_Matrix">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">nltools.data.</span></span><span class="sig-name descname"><span class="pre">Design_Matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Design_Matrix is a class to represent design matrices with special methods for data processing (e.g. convolution, upsampling, downsampling) and also intelligent and flexible and intelligent appending (e.g. auto-matically keep certain columns or polynomial terms separated during concatentation). It plays nicely with Brain_Data and can be used to build an experimental design to pass to Brain_Data’s X attribute. It is essentially an enhanced pandas df, with extra attributes and methods. Methods always return a new design matrix instance (copy). Column names are always string types.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sampling_freq</strong> (<em>float</em>) – sampling rate of each row in hertz; To covert seconds to hertz (e.g. in the case of TRs for neuroimaging) using hertz = 1 / TR</p></li>
<li><p><strong>convolved</strong> (<em>list</em><em>, </em><em>optional</em>) – on what columns convolution has been performed; defaults to None</p></li>
<li><p><strong>polys</strong> (<em>list</em><em>, </em><em>optional</em>) – list of polynomial terms in design matrix, e.g. intercept, polynomial trends, basis functions, etc; default None</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Design_Matrix.add_dct_basis">
<span class="sig-name descname"><span class="pre">add_dct_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">duration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">180</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix.add_dct_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix.add_dct_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds unit scaled cosine basis functions to Design_Matrix columns,
based on spm-style discrete cosine transform for use in
high-pass filtering. Does not add intercept/constant. Care is recommended if using this along with <cite>.add_poly()</cite>, as some columns will be highly-correlated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>duration</strong> (<em>int</em>) – length of filter in seconds</p></li>
<li><p><strong>drop</strong> (<em>int</em>) – index of which early/slow bases to drop if any; will always drop constant (i.e. intercept) like SPM. Unlike SPM, retains first basis (i.e. linear/sigmoidal). Will cumulatively drop bases up to and inclusive of index provided (e.g. 2, drops bases 1 and 2); default None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Design_Matrix.add_poly">
<span class="sig-name descname"><span class="pre">add_poly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix.add_poly"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix.add_poly" title="Permalink to this definition">¶</a></dt>
<dd><p>Add nth order Legendre polynomial terms as columns to design matrix. Good for adding constant/intercept to model (order = 0) and accounting for slow-frequency nuisance artifacts e.g. linear, quadratic, etc drifts. Care is recommended when using this with <cite>.add_dct_basis()</cite> as some columns will be highly correlated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>order</strong> (<em>int</em>) – what order terms to add; 0 = constant/intercept
(default), 1 = linear, 2 = quadratic, etc</p></li>
<li><p><strong>include_lower</strong> – (bool) whether to add lower order terms if order &gt; 0</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Design_Matrix.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_separate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unique_cols</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_na</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix.append"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for concatenating another design matrix row or column-wise. When concatenating row-wise, has the ability to keep certain columns separated if they exist in multiple design matrices (e.g. keeping separate intercepts for multiple runs). This is on by default and will automatically separate out polynomial columns (i.e. anything added with the <cite>add_poly</cite> or <cite>add_dct_basis</cite> methods). Additional columns can be separate by run using the <cite>unique_cols</cite> parameter. Can also add new polynomial terms during vertical concatentation (when axis == 0). This will by default create new polynomial terms separately for each design matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dm</strong> (<a class="reference internal" href="#nltools.data.Design_Matrix" title="nltools.data.Design_Matrix"><em>Design_Matrix</em></a><em> or </em><em>list</em>) – design_matrix or list of design_matrices to append</p></li>
<li><p><strong>axis</strong> (<em>int</em>) – 0 for row-wise (vert-cat), 1 for column-wise (horz-cat); default 0</p></li>
<li><p><strong>keep_separate</strong> (<em>bool</em><em>,</em><em>optional</em>) – whether try and uniquify columns;
defaults to True; only applies
when axis==0</p></li>
<li><p><strong>unique_cols</strong> (<em>list</em><em>,</em><em>optional</em>) – what additional columns to try to keep
separated by uniquifying, only applies when
axis = 0; defaults to None</p></li>
<li><p><strong>fill_na</strong> (<em>str/int/float</em>) – if provided will fill NaNs with this value during row-wise appending (when axis = 0) if separate columns are desired; default 0</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – print messages during append about how polynomials are going to be separated</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Design_Matrix.clean">
<span class="sig-name descname"><span class="pre">clean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fill_na</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_polys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thresh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix.clean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix.clean" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to fill NaNs in Design Matrix and remove duplicate columns based on data values, NOT names. Columns are dropped if they are correlated &gt;= the requested threshold (default = .95). In this case, only the first instance of that column will be retained and all others will be dropped.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fill_na</strong> (<em>str/int/float</em>) – value to fill NaNs with set to None to retain NaNs; default 0</p></li>
<li><p><strong>exclude_polys</strong> (<em>bool</em>) – whether to skip checking of polynomial terms (i.e. intercept, trends, basis functions); default False</p></li>
<li><p><strong>thresh</strong> (<em>float</em>) – correlation threshold to use to drop redundant columns; default .95</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – print what column names were dropped; default True</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Design_Matrix.convolve">
<span class="sig-name descname"><span class="pre">convolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">conv_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hrf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">columns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix.convolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix.convolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform convolution using an arbitrary function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>conv_func</strong> (<em>ndarray</em><em> or </em><em>string</em>) – either a 1d numpy array containing output of a function that you want to convolve; a samples by kernel 2d array of several kernels to convolve; or the string ‘hrf’ which defaults to a glover HRF function at the Design_matrix’s sampling_freq</p></li>
<li><p><strong>columns</strong> (<em>list</em>) – what columns to perform convolution on; defaults
to all non-polynomial columns</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Design_Matrix.downsample">
<span class="sig-name descname"><span class="pre">downsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix.downsample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix.downsample" title="Permalink to this definition">¶</a></dt>
<dd><p>Downsample columns of design matrix. Relies on nltools.stats.downsample, but ensures that returned object is a design matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> (<em>float</em>) – desired frequency in hz</p></li>
<li><p><strong>kwargs</strong> – additional inputs to nltools.stats.downsample</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Design_Matrix.heatmap">
<span class="sig-name descname"><span class="pre">heatmap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(8,</span> <span class="pre">6)</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix.heatmap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix.heatmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize Design Matrix spm style. Use .plot() for typical pandas
plotting functionality. Can pass optional keyword args to seaborn
heatmap.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Design_Matrix.replace_data">
<span class="sig-name descname"><span class="pre">replace_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">column_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix.replace_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix.replace_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenient method to replace all data in Design_Matrix with new data while keeping attributes and polynomial columns untouched.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>columns_names</strong> (<em>list</em>) – list of columns names for new data</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Design_Matrix.upsample">
<span class="sig-name descname"><span class="pre">upsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix.upsample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix.upsample" title="Permalink to this definition">¶</a></dt>
<dd><p>Upsample columns of design matrix. Relies on nltools.stats.upsample, but ensures that returned object is a design matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> (<em>float</em>) – desired frequence in hz</p></li>
<li><p><strong>kwargs</strong> – additional inputs to nltools.stats.downsample</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Design_Matrix.vif">
<span class="sig-name descname"><span class="pre">vif</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exclude_polys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix.vif"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix.vif" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute variance inflation factor amongst columns of design matrix,ignoring
polynomial terms. Much faster that statsmodels and more reliable too. Uses the
same method as Matlab and R (diagonal elements of the inverted correlation
matrix).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>exclude_polys</strong> (<em>bool</em>) – whether to skip checking of polynomial terms (i.e intercept, trends, basis functions); default True</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>list with length == number of columns - intercept</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>vifs (list)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.data.Design_Matrix.zscore">
<span class="sig-name descname"><span class="pre">zscore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">columns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix.zscore"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix.zscore" title="Permalink to this definition">¶</a></dt>
<dd><p>Z-score specific columns of design matrix. Relies on nltools.stats.downsample, but ensures that returned object is a design matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>columns</strong> (<em>list</em>) – columns to z-score; defaults to all columns</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="nltools-analysis-analysis-tools">
<h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.analysis</span></code>: Analysis Tools<a class="headerlink" href="#nltools-analysis-analysis-tools" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="nltools.analysis.Roc">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">nltools.analysis.</span></span><span class="sig-name descname"><span class="pre">Roc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">binary_outcome</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'optimal_overall'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forced_choice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/analysis.html#Roc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.analysis.Roc" title="Permalink to this definition">¶</a></dt>
<dd><p>Roc Class</p>
<p>The Roc class is based on Tor Wager’s Matlab roc_plot.m function and
allows a user to easily run different types of receiver operator
characteristic curves.  For example, one might be interested in single
interval or forced choice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_values</strong> – nibabel data instance</p></li>
<li><p><strong>binary_outcome</strong> – vector of training labels</p></li>
<li><p><strong>threshold_type</strong> – [‘optimal_overall’, ‘optimal_balanced’,
‘minimum_sdt_bias’]</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments to pass to the prediction
algorithm</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="nltools.analysis.Roc.calculate">
<span class="sig-name descname"><span class="pre">calculate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">binary_outcome</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">criterion_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'optimal_overall'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forced_choice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">balanced_acc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/analysis.html#Roc.calculate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.analysis.Roc.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Receiver Operating Characteristic plot (ROC) for
single-interval classification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_values</strong> – nibabel data instance</p></li>
<li><p><strong>binary_outcome</strong> – vector of training labels</p></li>
<li><p><strong>criterion_values</strong> – (optional) criterion values for calculating fpr
&amp; tpr</p></li>
<li><p><strong>threshold_type</strong> – [‘optimal_overall’, ‘optimal_balanced’,
‘minimum_sdt_bias’]</p></li>
<li><p><strong>forced_choice</strong> – index indicating position for each unique subject
(default=None)</p></li>
<li><p><strong>balanced_acc</strong> – balanced accuracy for single-interval classification
(bool). THIS IS NOT COMPLETELY IMPLEMENTED BECAUSE
IT AFFECTS ACCURACY ESTIMATES, BUT NOT P-VALUES OR
THRESHOLD AT WHICH TO EVALUATE SENS/SPEC</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments to pass to the prediction
algorithm</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.analysis.Roc.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plot_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gaussian'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">balanced_acc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/analysis.html#Roc.plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.analysis.Roc.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Create ROC Plot</p>
<p>Create a specific kind of ROC curve plot, based on input values
along a continuous distribution and a binary outcome variable (logical)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plot_method</strong> – type of plot [‘gaussian’,’observed’]</p></li>
<li><p><strong>binary_outcome</strong> – vector of training labels</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments to pass to the prediction
algorithm</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>fig</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.analysis.Roc.summary">
<span class="sig-name descname"><span class="pre">summary</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/analysis.html#Roc.summary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.analysis.Roc.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Display a formatted summary of ROC analysis.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-nltools.stats">
<span id="nltools-stats-stats-tools"></span><h2><a class="reference internal" href="#module-nltools.stats" title="nltools.stats"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.stats</span></code></a>: Stats Tools<a class="headerlink" href="#module-nltools.stats" title="Permalink to this heading">¶</a></h2>
<section id="neurolearn-statistics-tools">
<h3>NeuroLearn Statistics Tools<a class="headerlink" href="#neurolearn-statistics-tools" title="Permalink to this heading">¶</a></h3>
<p>Tools to help with statistical analyses.</p>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.align">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">align</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'deterministic_srm'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#align"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Align subject data into a common response model.</p>
<p>Can be used to hyperalign source data to target data using
Hyperalignment from Dartmouth (i.e., procrustes transformation; see
nltools.stats.procrustes) or Shared Response Model from Princeton (see
nltools.external.srm). (see nltools.data.Brain_Data.align for aligning
a single Brain object to another). Common Model is shared response
model or centered target data. Transformed data can be back projected to
original data using Tranformation matrix. Inputs must be a list of Brain_Data
instances or numpy arrays (observations by features).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – (list) A list of Brain_Data objects</p></li>
<li><p><strong>method</strong> – (str) alignment method to use
[‘probabilistic_srm’,’deterministic_srm’,’procrustes’]</p></li>
<li><p><strong>n_features</strong> – (int) number of features to align to common space.
If None then will select number of voxels</p></li>
<li><p><strong>axis</strong> – (int) axis to align on</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(dict) a dictionary containing a list of transformed subject</dt><dd><p>matrices, a list of transformation matrices, the shared
response matrix, and the intersubject correlation of the shared resposnes</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<ul>
<li><dl>
<dt>Hyperalign using procrustes transform:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">align</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;procrustes&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl>
<dt>Align using shared response model:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">align</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;probabilistic_srm&#39;</span><span class="p">,</span> <span class="n">n_features</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl>
<dt>Project aligned data into original data:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">original_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">tm</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span><span class="p">,</span><span class="n">tm</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;transformed&#39;</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;transformation_matrix&#39;</span><span class="p">])]</span>
</pre></div>
</div>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.align_states">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">align_states</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'correlation'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replace_zero_variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#align_states"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.align_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Align state weight maps using hungarian algorithm by minimizing pairwise distance between group states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> – (np.array) reference pattern x state matrix</p></li>
<li><p><strong>target</strong> – (np.array) target pattern x state matrix to align to reference</p></li>
<li><p><strong>metric</strong> – (str) distance metric to use</p></li>
<li><p><strong>return_index</strong> – (bool) return index if True, return remapped data if False</p></li>
<li><p><strong>replace_zero_variance</strong> – (bool) transform a vector with zero variance to random numbers from a uniform distribution.
Useful for when using correlation as a distance metric to avoid NaNs.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(list) a list of reordered state X pattern matrices</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ordered_weights</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.calc_bpm">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">calc_bpm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beat_interval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_freq</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#calc_bpm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.calc_bpm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate instantaneous BPM from beat to beat interval</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>beat_interval</strong> – (int) number of samples in between each beat
(typically R-R Interval)</p></li>
<li><p><strong>sampling_freq</strong> – (float) sampling frequency in Hz</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(float) beats per minute for time interval</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bpm</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.correlation">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">correlation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pearson'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#correlation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the correlation between data1 and data2</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data1</strong> – (np.array) x</p></li>
<li><p><strong>data2</strong> – (np.array) y</p></li>
<li><p><strong>metric</strong> – (str) type of correlation [“spearman” or “pearson” or “kendall”]</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(np.array) correlations
p: (float) p-value</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>r</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.correlation_permutation">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">correlation_permutation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'permute'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'spearman'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_perms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#correlation_permutation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.correlation_permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute correlation and calculate p-value using permutation methods.</p>
<p>‘permute’ method randomly shuffles one of the vectors. This method is recommended
for independent data. For timeseries data we recommend using ‘circle_shift’ or
‘phase_randomize’ methods.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data1</strong> – (pd.DataFrame, pd.Series, np.array) dataset 1 to permute</p></li>
<li><p><strong>data2</strong> – (pd.DataFrame, pd.Series, np.array) dataset 2 to permute</p></li>
<li><p><strong>n_permute</strong> – (int) number of permutations</p></li>
<li><p><strong>metric</strong> – (str) type of association metric [‘spearman’,’pearson’,
‘kendall’]</p></li>
<li><p><strong>method</strong> – (str) type of permutation [‘permute’, ‘circle_shift’, ‘phase_randomize’]</p></li>
<li><p><strong>random_state</strong> – (int, None, or np.random.RandomState) Initial random seed (default: None)</p></li>
<li><p><strong>tail</strong> – (int) either 1 for one-tail or 2 for two-tailed test (default: 2)</p></li>
<li><p><strong>n_jobs</strong> – (int) The number of CPUs to use to do the computation.
-1 means all CPUs.</p></li>
<li><p><strong>return_parms</strong> – (bool) Return the permutation distribution along with the p-value; default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(dict) dictionary of permutation results [‘correlation’,’p’]</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>stats</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.distance_correlation">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">distance_correlation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias_corrected</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ttest</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#distance_correlation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.distance_correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the distance correlation betwen 2 arrays to test for multivariate dependence (linear or non-linear). Arrays must match on their first dimension. It’s almost always preferable to compute the bias_corrected version which can also optionally perform a ttest. This ttest operates on a statistic thats ~dcorr^2 and will be also returned.</p>
<p>Explanation:
Distance correlation involves computing the normalized covariance of two centered euclidean distance matrices. Each distance matrix is the euclidean distance between rows (if x or y are 2d) or scalars (if x or y are 1d). Each matrix is centered prior to computing the covariance either using double-centering or u-centering, which corrects for bias as the number of dimensions increases. U-centering is almost always preferred in all cases. It also permits inference of the normalized covariance between each distance matrix using a one-tailed directional t-test. (Szekely &amp; Rizzo, 2013). While distance correlation is normally bounded between 0 and 1, u-centering can produce negative estimates, which are never significant.</p>
<p>Validated against the dcor and dcor.ttest functions in the ‘energy’ R package and the dcor.distance_correlation, dcor.udistance_correlation_sqr, and dcor.independence.distance_correlation_t_test functions in the dcor Python package.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – 1d or 2d numpy array of observations by features</p></li>
<li><p><strong>y</strong> (<em>ndarry</em>) – 1d or 2d numpy array of observations by features</p></li>
<li><p><strong>bias_corrected</strong> (<em>bool</em>) – if false use double-centering which produces a biased-estimate that converges to 1 as the number of dimensions increase. Otherwise used u-centering to correct this bias. <strong>Note</strong> this must be True if ttest=True; default True</p></li>
<li><p><strong>ttest</strong> (<em>bool</em>) – perform a ttest using the bias_corrected distance correlation; default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>dictionary of results (correlation, t, p, and df.) Optionally, covariance, x variance, and y variance</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>results (dict)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.double_center">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">double_center</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#double_center"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.double_center" title="Permalink to this definition">¶</a></dt>
<dd><p>Double center a 2d array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mat</strong> (<em>ndarray</em>) – 2d numpy array</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>double-centered version of input</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>mat (ndarray)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.downsample">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">downsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'samples'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#downsample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.downsample" title="Permalink to this definition">¶</a></dt>
<dd><p>Downsample pandas to a new target frequency or number of samples
using averaging.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – (pd.DataFrame, pd.Series) data to downsample</p></li>
<li><p><strong>sampling_freq</strong> – (float) Sampling frequency of data in hertz</p></li>
<li><p><strong>target</strong> – (float) downsampling target</p></li>
<li><p><strong>target_type</strong> – type of target can be [samples,seconds,hz]</p></li>
<li><p><strong>method</strong> – (str) type of downsample method [‘mean’,’median’],
default: mean</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(pd.DataFrame, pd.Series) downsmapled data</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.fdr">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">fdr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#fdr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.fdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine FDR threshold given a p value array and desired false
discovery rate q. Written by Tal Yarkoni</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> – (np.array) vector of p-values</p></li>
<li><p><strong>q</strong> – (float) false discovery rate level</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(float) p-value threshold based on independence or positive</dt><dd><p>dependence</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>fdr_p</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.find_spikes">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">find_spikes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">global_spike_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diff_spike_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#find_spikes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.find_spikes" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to identify spikes from fMRI Time Series Data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – Brain_Data or nibabel instance</p></li>
<li><p><strong>global_spike_cutoff</strong> – (int,None) cutoff to identify spikes in global signal
in standard deviations, None indicates do not calculate.</p></li>
<li><p><strong>diff_spike_cutoff</strong> – (int,None) cutoff to identify spikes in average frame difference
in standard deviations, None indicates do not calculate.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pandas dataframe with spikes as indicator variables</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.fisher_r_to_z">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">fisher_r_to_z</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#fisher_r_to_z"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.fisher_r_to_z" title="Permalink to this definition">¶</a></dt>
<dd><p>Use Fisher transformation to convert correlation to z score</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.fisher_z_to_r">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">fisher_z_to_r</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#fisher_z_to_r"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.fisher_z_to_r" title="Permalink to this definition">¶</a></dt>
<dd><p>Use Fisher transformation to convert correlation to z score</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.holm_bonf">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">holm_bonf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#holm_bonf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.holm_bonf" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute corrected p-values based on the Holm-Bonferroni method, i.e. step-down procedure applying iteratively less correction to highest p-values. A bit more conservative than fdr, but much more powerful thanvanilla bonferroni.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> – (np.array) vector of p-values</p></li>
<li><p><strong>alpha</strong> – (float) alpha level</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(float) p-value threshold based on bonferroni</dt><dd><p>step-down procedure</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bonf_p</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.isc">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">isc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'median'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'bootstrap'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci_percentile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_self_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_null</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#isc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.isc" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute pairwise intersubject correlation from observations by subjects array.</p>
<p>This function computes pairwise intersubject correlations (ISC) using the median as recommended by Chen
et al., 2016). However, if the mean is preferred, we compute the mean correlation after performing
the fisher r-to-z transformation and then convert back to correlations to minimize artificially
inflating the correlation values.</p>
<p>There are currently three different methods to compute p-values. These include the classic methods for
computing permuted time-series by either circle-shifting the data or phase-randomizing the data
(see Lancaster et al., 2018). These methods create random surrogate data while preserving the temporal
autocorrelation inherent to the signal. By default, we use the subject-wise bootstrap method from
Chen et al., 2016. Instead of recomputing the pairwise ISC using circle_shift or phase_randomization methods,
this approach uses the computationally more efficient method of bootstrapping the subjects
and computing a new pairwise similarity matrix with randomly selected subjects with replacement.
If the same subject is selected multiple times, we set the perfect correlation to a nan with
(exclude_self_corr=True). We compute the p-values using the percentile method using the same
method in Brainiak.</p>
<p>Chen, G., Shin, Y. W., Taylor, P. A., Glen, D. R., Reynolds, R. C., Israel, R. B.,
&amp; Cox, R. W. (2016). Untangling the relatedness among correlations, part I:
nonparametric approaches to inter-subject correlation analysis at the group level.
NeuroImage, 142, 248-259.</p>
<p>Hall, P., &amp; Wilson, S. R. (1991). Two guidelines for bootstrap hypothesis testing.
Biometrics, 757-762.</p>
<p>Lancaster, G., Iatsenko, D., Pidde, A., Ticcinelli, V., &amp; Stefanovska, A. (2018).
Surrogate data for hypothesis testing of physical systems. Physics Reports, 748, 1-60.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – (pd.DataFrame, np.array) observations by subjects where isc is computed across subjects</p></li>
<li><p><strong>n_samples</strong> – (int) number of random samples/bootstraps</p></li>
<li><p><strong>metric</strong> – (str) type of isc summary metric [‘mean’,’median’]</p></li>
<li><p><strong>method</strong> – (str) method to compute p-values [‘bootstrap’, ‘circle_shift’,’phase_randomize’] (default: bootstrap)</p></li>
<li><p><strong>tail</strong> – (int) either 1 for one-tail or 2 for two-tailed test (default: 2)</p></li>
<li><p><strong>n_jobs</strong> – (int) The number of CPUs to use to do the computation. -1 means all CPUs.</p></li>
<li><p><strong>return_null</strong> – (bool) Return the permutation distribution along with the p-value; default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(dict) dictionary of permutation results [‘correlation’,’p’]</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>stats</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.isc_group">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">isc_group</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'median'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'permute'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci_percentile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_self_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_null</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#isc_group"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.isc_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute difference in intersubject correlation between groups.</p>
<p>This function computes pairwise intersubject correlations (ISC) using the median as recommended by Chen
et al., 2016). However, if the mean is preferred, we compute the mean correlation after performing
the fisher r-to-z transformation and then convert back to correlations to minimize artificially
inflating the correlation values.</p>
<p>There are currently two different methods to compute p-values. By default, we use the subject-wise permutation
method recommended Chen et al., 2016. This method combines the two groups and computes pairwise similarity both
within and between the groups. Then the group labels are permuted and the mean difference between the two groups
are recomputed to generate a null distribution. The second method uses subject-wise bootstrapping, where a new
pairwise similarity matrix with randomly selected subjects with replacement is created separately for each group
and the ISC difference between these groups is used to generate a null distribution. If the same subject is
selected multiple times, we set the perfect correlation to a nan with (exclude_self_corr=True). We compute the
p-values using the percentile method (Hall &amp; Wilson, 1991).</p>
<p>Chen, G., Shin, Y. W., Taylor, P. A., Glen, D. R., Reynolds, R. C., Israel, R. B.,
&amp; Cox, R. W. (2016). Untangling the relatedness among correlations, part I:
nonparametric approaches to inter-subject correlation analysis at the group level.
NeuroImage, 142, 248-259.</p>
<p>Hall, P., &amp; Wilson, S. R. (1991). Two guidelines for bootstrap hypothesis testing.
Biometrics, 757-762.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group1</strong> – (pd.DataFrame, np.array) observations by subjects where isc is computed across subjects</p></li>
<li><p><strong>group2</strong> – (pd.DataFrame, np.array) observations by subjects where isc is computed across subjects</p></li>
<li><p><strong>n_samples</strong> – (int) number of samples for permutation or bootstrapping</p></li>
<li><p><strong>metric</strong> – (str) type of isc summary metric [‘mean’,’median’]</p></li>
<li><p><strong>method</strong> – (str) method to compute p-values [‘bootstrap’, ‘circle_shift’,’phase_randomize’] (default: bootstrap)</p></li>
<li><p><strong>tail</strong> – (int) either 1 for one-tail or 2 for two-tailed test (default: 2)</p></li>
<li><p><strong>n_jobs</strong> – (int) The number of CPUs to use to do the computation. -1 means all CPUs.</p></li>
<li><p><strong>return_null</strong> – (bool) Return the permutation distribution along with the p-value; default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(dict) dictionary of permutation results [‘correlation’,’p’]</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>stats</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.isfc">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">isfc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'average'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#isfc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.isfc" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute intersubject functional connectivity (ISFC) from a list of observation x feature matrices</p>
<p>This function uses the leave one out approach to compute ISFC (Simony et al., 2016).
For each subject, compute the cross-correlation between each voxel/roi
with the average of the rest of the subjects data. In other words,
compute the mean voxel/ROI response for all participants except the
target subject. Then compute the correlation between each ROI within
the target subject with the mean ROI response in the group average.</p>
<p>Simony, E., Honey, C. J., Chen, J., Lositsky, O., Yeshurun, Y., Wiesel, A., &amp; Hasson, U. (2016).
Dynamic reconfiguration of the default mode network during narrative comprehension.
Nature communications, 7, 12141.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – list of subject matrices (observations x voxels/rois)</p></li>
<li><p><strong>method</strong> – approach to computing ISFC. ‘average’ uses leave one</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>list of subject ISFC matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.isps">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">isps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.04</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high_cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pairwise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#isps"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.isps" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Dynamic Intersubject Phase Synchrony (ISPS from a observation by subject array)</p>
<p>This function computes the instantaneous intersubject phase synchrony for a single voxel/roi
timeseries. Requires multiple subjects. This method is largely based on that described by Glerean
et al., 2012 and performs a hilbert transform on narrow bandpass filtered timeseries (butterworth)
data to get the instantaneous phase angle. The function returns a dictionary containing the
average phase angle, the average vector length, and parametric p-values computed using the rayleigh test using circular
statistics (Fisher, 1993). If pairwise=True, then it will compute these on the pairwise phase angle differences,
if pairwise=False, it will compute these on the actual phase angles. This is called inter-site phase coupling
or inter-trial phase coupling respectively in the EEG literatures.</p>
<p>This function requires narrow band filtering your data. As a default we use the recommendations
by (Glerean et al., 2012) of .04-.07Hz. This is similar to the “slow-4” band (0.025–0.067 Hz)
described by (Zuo et al., 2010; Penttonen &amp; Buzsáki, 2003), but excludes the .03 band, which has been
demonstrated to contain aliased respiration signals (Birn, 2006).</p>
<p>Birn RM, Smith MA, Bandettini PA, Diamond JB. 2006. Separating respiratory-variation-related
fluctuations from neuronal-activity- related fluctuations in fMRI. Neuroimage 31:1536–1548.</p>
<p>Buzsáki, G., &amp; Draguhn, A. (2004). Neuronal oscillations in cortical networks. Science,
304(5679), 1926-1929.</p>
<p>Fisher, N. I. (1995). Statistical analysis of circular data. cambridge university press.</p>
<p>Glerean, E., Salmi, J., Lahnakoski, J. M., Jääskeläinen, I. P., &amp; Sams, M. (2012).
Functional magnetic resonance imaging phase synchronization as a measure of dynamic
functional connectivity. Brain connectivity, 2(2), 91-101.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – (pd.DataFrame, np.ndarray) observations x subjects data</p></li>
<li><p><strong>sampling_freq</strong> – (float) sampling freqency of data in Hz</p></li>
<li><p><strong>low_cut</strong> – (float) lower bound cutoff for high pass filter</p></li>
<li><p><strong>high_cut</strong> – (float) upper bound cutoff for low pass filter</p></li>
<li><p><strong>order</strong> – (int) filter order for butterworth bandpass</p></li>
<li><p><strong>pairwise</strong> – (bool) compute phase angle coherence on pairwise phase angle differences
or on raw phase angle.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>dictionary with mean phase angle, vector length, and rayleigh statistic</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.make_cosine_basis">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">make_cosine_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nsamples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#make_cosine_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.make_cosine_basis" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Create a series of cosine basis functions for a discrete cosine</dt><dd><p>transform. Based off of implementation in spm_filter and spm_dctmtx
because scipy dct can only apply transforms but not return the basis
functions. Like SPM, does not add constant (i.e. intercept), but does
retain first basis (i.e. sigmoidal/linear drift)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nsamples</strong> (<em>int</em>) – number of observations (e.g. TRs)</p></li>
<li><p><strong>sampling_freq</strong> (<em>float</em>) – sampling frequency in hertz (i.e. 1 / TR)</p></li>
<li><p><strong>filter_length</strong> (<em>int</em>) – length of filter in seconds</p></li>
<li><p><strong>unit_scale</strong> (<em>true</em>) – assure that the basis functions are on the normalized range [-1, 1]; default True</p></li>
<li><p><strong>drop</strong> (<em>int</em>) – index of which early/slow bases to drop if any; default is
to drop constant (i.e. intercept) like SPM. Unlike SPM, retains
first basis (i.e. linear/sigmoidal). Will cumulatively drop bases
up to and inclusive of index provided (e.g. 2, drops bases 1 and 2)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>nsamples x number of basis sets numpy array</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out (ndarray)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.matrix_permutation">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">matrix_permutation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'spearman'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">how</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'upper'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_diag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_perms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#matrix_permutation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.matrix_permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Permute 2-dimensional matrix correlation (mantel test).</p>
<p>Chen, G. et al. (2016). Untangling the relatedness among correlations,
part I: nonparametric approaches to inter-subject correlation analysis
at the group level. Neuroimage, 142, 248-259.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data1</strong> – (pd.DataFrame, np.array) square matrix</p></li>
<li><p><strong>data2</strong> – (pd.DataFrame, np.array) square matrix</p></li>
<li><p><strong>n_permute</strong> – (int) number of permutations</p></li>
<li><p><strong>metric</strong> – (str) type of association metric [‘spearman’,’pearson’,
‘kendall’]</p></li>
<li><p><strong>how</strong> – (str) whether to use the ‘upper’ (default), ‘lower’, or ‘full’ matrix. The
default of ‘upper’ assumes both matrices are symmetric</p></li>
<li><p><strong>include_diag</strong> (<em>bool</em>) – only applies if <cite>how=’full’</cite>. Whether to include the
diagonal elements in the comparison</p></li>
<li><p><strong>tail</strong> – (int) either 1 for one-tail or 2 for two-tailed test
(default: 2)</p></li>
<li><p><strong>n_jobs</strong> – (int) The number of CPUs to use to do the computation.
-1 means all CPUs.</p></li>
<li><p><strong>return_parms</strong> – (bool) Return the permutation distribution along with the p-value; default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(dict) dictionary of permutation results [‘correlation’,’p’]</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>stats</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.multi_threshold">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">multi_threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thresh</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#multi_threshold"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.multi_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Threshold test image by multiple p-value from p image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stat</strong> – (Brain_Data) Brain_Data instance of arbitrary statistic metric
(e.g., beta, t, etc)</p></li>
<li><p><strong>p</strong> – (Brain_Data) Brain_data instance of p-values</p></li>
<li><p><strong>threshold</strong> – (list) list of p-values to threshold stat image</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Thresholded Brain_Data instance</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.one_sample_permutation">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">one_sample_permutation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_perms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#one_sample_permutation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.one_sample_permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>One sample permutation test using randomization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – (pd.DataFrame, pd.Series, np.array) data to permute</p></li>
<li><p><strong>n_permute</strong> – (int) number of permutations</p></li>
<li><p><strong>tail</strong> – (int) either 1 for one-tail or 2 for two-tailed test (default: 2)</p></li>
<li><p><strong>n_jobs</strong> – (int) The number of CPUs to use to do the computation.
-1 means all CPUs.</p></li>
<li><p><strong>return_parms</strong> – (bool) Return the permutation distribution along with the p-value; default False</p></li>
<li><p><strong>random_state</strong> – (int, None, or np.random.RandomState) Initial random seed (default: None)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(dict) dictionary of permutation results [‘mean’,’p’]</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>stats</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.pearson">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">pearson</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#pearson"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.pearson" title="Permalink to this definition">¶</a></dt>
<dd><p>Correlates row vector x with each row vector in 2D array y.
From neurosynth.stats.py - author: Tal Yarkoni</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.procrustes">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">procrustes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#procrustes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.procrustes" title="Permalink to this definition">¶</a></dt>
<dd><p>Procrustes analysis, a similarity test for two data sets.</p>
<p>Each input matrix is a set of points or vectors (the rows of the matrix).
The dimension of the space is the number of columns of each matrix. Given
two identically sized matrices, procrustes standardizes both such that:
- <span class="math notranslate nohighlight">\(tr(AA^{T}) = 1\)</span>.
- Both sets of points are centered around the origin.
Procrustes (<a href="#id4"><span class="problematic" id="id1">[1]_</span></a>, <a href="#id5"><span class="problematic" id="id2">[2]_</span></a>) then applies the optimal transform to the second
matrix (including scaling/dilation, rotations, and reflections) to minimize
<span class="math notranslate nohighlight">\(M^{2}=\sum(data1-data2)^{2}\)</span>, or the sum of the squares of the
pointwise differences between the two input datasets.
This function was not designed to handle datasets with different numbers of
datapoints (rows).  If two data sets have different dimensionality
(different number of columns), this function will add columns of zeros to
the smaller of the two.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data1</strong> – array_like
Matrix, n rows represent points in k (columns) space <cite>data1</cite> is the
reference data, after it is standardised, the data from <cite>data2</cite>
will be transformed to fit the pattern in <cite>data1</cite> (must have &gt;1
unique points).</p></li>
<li><p><strong>data2</strong> – array_like
n rows of data in k space to be fit to <cite>data1</cite>.  Must be the  same
shape <code class="docutils literal notranslate"><span class="pre">(numrows,</span> <span class="pre">numcols)</span></code> as data1 (must have &gt;1 unique points).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>array_like</dt><dd><p>A standardized version of <cite>data1</cite>.</p>
</dd>
<dt>mtx2<span class="classifier">array_like</span></dt><dd><p>The orientation of <cite>data2</cite> that best fits <cite>data1</cite>. Centered, but not
necessarily <span class="math notranslate nohighlight">\(tr(AA^{T}) = 1\)</span>.</p>
</dd>
<dt>disparity<span class="classifier">float</span></dt><dd><p><span class="math notranslate nohighlight">\(M^{2}\)</span> as defined above.</p>
</dd>
<dt>R<span class="classifier">(N, N) ndarray</span></dt><dd><p>The matrix solution of the orthogonal Procrustes problem.
Minimizes the Frobenius norm of dot(data1, R) - data2, subject to
dot(R.T, R) == I.</p>
</dd>
<dt>scale<span class="classifier">float</span></dt><dd><p>Sum of the singular values of <code class="docutils literal notranslate"><span class="pre">dot(data1.T,</span> <span class="pre">data2)</span></code>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>mtx1</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.procrustes_distance">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">procrustes_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mat2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#procrustes_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.procrustes_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Use procrustes super-position to perform a similarity test between 2 matrices. Matrices need to match in size on their first dimension only, as the smaller matrix on the second dimension will be padded with zeros. After aligning two matrices using the procrustes transformation, use the computed disparity between them (sum of squared error of elements) as a similarity metric. Shuffle the rows of one of the matrices and recompute the disparity to perform inference (Peres-Neto &amp; Jackson, 2001).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mat1</strong> (<em>ndarray</em>) – 2d numpy array; must have same number of rows as mat2</p></li>
<li><p><strong>mat2</strong> (<em>ndarray</em>) – 1d or 2d numpy array; must have same number of rows as mat1</p></li>
<li><p><strong>n_permute</strong> (<em>int</em>) – number of permutation iterations to perform</p></li>
<li><p><strong>tail</strong> (<em>int</em>) – either 1 for one-tailed or 2 for two-tailed test; default 2</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of CPUs to use to do permutation; default -1 (all)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>similarity between matrices bounded between 0 and 1
pval (float): permuted p-value</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>similarity (float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.regress">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">regress</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ols'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'full'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#regress"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.regress" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a flexible function to run several types of regression models provided X and Y numpy arrays. Y can be a 1d numpy array or 2d numpy array. In the latter case, results will be output with shape 1 x Y.shape[1], in other words fitting a separate regression model to each column of Y.</p>
<p>Does NOT add an intercept automatically to the X matrix before fitting like some other software packages. This is left up to the user.</p>
<p>This function can compute regression in 3 ways:</p>
<ol class="arabic simple">
<li><p>Standard OLS</p></li>
<li><p>OLS with robust sandwich estimators for standard errors. 3 robust types of
estimators exist:</p></li>
</ol>
<ul class="simple">
<li><p>‘hc0’ - classic huber-white estimator robust to heteroscedasticity (default)</p></li>
<li><p>‘hc3’ - a variant on huber-white estimator slightly more conservative when sample sizes are small</p></li>
<li><p>‘hac’ - an estimator robust to both heteroscedasticity and auto-correlation;
auto-correlation lag can be controlled with the <cite>nlags</cite> keyword argument; default
is 1</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>ARMA (auto-regressive moving-average) model (experimental). This model is fit through statsmodels.tsa.arima_model.ARMA, so more information about options can be found there. Any settings can be passed in as kwargs. By default fits a (1,1) model with starting lags of 2. This mode is <strong>computationally intensive</strong> and can take quite a while if Y has many columns.  If Y is a 2d array joblib.Parallel is used for faster fitting by parallelizing fits across columns of Y. Parallelization can be controlled by passing in kwargs. Defaults to multi-threading using 10 separate threads, as threads don’t require large arrays to be duplicated in memory. Defaults are also set to enable memory-mapping for very large arrays if backend=’multiprocessing’ to prevent crashes and hangs. Various levels of progress can be monitored using the ‘disp’ (statsmodels) and ‘verbose’ (joblib) keyword arguments with integer values &gt; 0.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>ndarray</em>) – design matrix; assumes intercept is included</p></li>
<li><p><strong>Y</strong> (<em>ndarray</em>) – dependent variable array; if 2d, a model is fit to each column of Y separately</p></li>
<li><p><strong>mode</strong> (<em>str</em>) – kind of model to fit; must be one of ‘ols’ (default), ‘robust’, or</p></li>
<li><p><strong>'arma'</strong> – </p></li>
<li><p><strong>stats</strong> (<em>str</em>) – one of ‘full’, ‘betas’, ‘tstats’. Useful to speed up calculation if</p></li>
<li><p><strong>'full'.</strong> (<em>you know you only need some statistics and not others. Defaults to</em>) – </p></li>
<li><p><strong>robust_estimator</strong> (<em>str</em><em>,</em><em>optional</em>) – kind of robust estimator to use if mode = ‘robust’; default ‘hc0’</p></li>
<li><p><strong>nlags</strong> (<em>int</em><em>,</em><em>optional</em>) – auto-correlation lag correction if mode = ‘robust’ and robust_estimator = ‘hac’; default 1</p></li>
<li><p><strong>order</strong> (<em>tuple</em><em>,</em><em>optional</em>) – auto-regressive and moving-average orders for mode = ‘arma’; default (1,1)</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – additional keyword arguments to statsmodels.tsa.arima_model.ARMA and joblib.Parallel</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>coefficients
se: standard error of coefficients
t: t-statistics (coef/sterr)
p : p-values
df: degrees of freedom
res: residuals</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>b</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Standard OLS</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">regress</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;ols&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Robust OLS with heteroscedasticity (hc0) robust standard errors</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">regress</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;robust&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Robust OLS with heteroscedasticty and auto-correlation (with lag 2) robust standard errors</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">regress</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;robust&#39;</span><span class="p">,</span><span class="n">robust_estimator</span><span class="o">=</span><span class="s1">&#39;hac&#39;</span><span class="p">,</span><span class="n">nlags</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Auto-regressive mode with auto-regressive and moving-average lags = 1</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">regress</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;arma&#39;</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>Auto-regressive model with auto-regressive lag = 2, moving-average lag = 3, and multi-processing instead of multi-threading using 8 cores (this can use a lot of memory if input arrays are very large!).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">regress</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;arma&#39;</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">backend</span><span class="o">=</span><span class="s1">&#39;multiprocessing&#39;</span><span class="p">,</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.summarize_bootstrap">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">summarize_bootstrap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#summarize_bootstrap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.summarize_bootstrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate summary of bootstrap samples</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sample</strong> – (Brain_Data) Brain_Data instance of samples</p></li>
<li><p><strong>save_weights</strong> – (bool) save bootstrap weights</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(dict) dictionary of Brain_Data summary images</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>output</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.threshold">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#threshold"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Threshold test image by p-value from p image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stat</strong> – (Brain_Data) Brain_Data instance of arbitrary statistic metric
(e.g., beta, t, etc)</p></li>
<li><p><strong>p</strong> – (Brain_Data) Brain_data instance of p-values</p></li>
<li><p><strong>threshold</strong> – (float) p-value to threshold stat image</p></li>
<li><p><strong>return_mask</strong> – (bool) optionall return the thresholding mask; default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Thresholded Brain_Data instance</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.transform_pairwise">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">transform_pairwise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#transform_pairwise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.transform_pairwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms data into pairs with balanced labels for ranking
Transforms a n-class ranking problem into a two-class classification
problem. Subclasses implementing particular strategies for choosing
pairs should override this method.
In this method, all pairs are choosen, except for those that have the
same target value. The output is an array of balanced classes, i.e.
there are the same number of -1 as +1</p>
<p>Reference: “Large Margin Rank Boundaries for Ordinal Regression”,
R. Herbrich, T. Graepel, K. Obermayer. Authors: Fabian Pedregosa
&lt;<a class="reference external" href="mailto:fabian&#37;&#52;&#48;fseoane&#46;net">fabian<span>&#64;</span>fseoane<span>&#46;</span>net</a>&gt; Alexandre Gramfort &lt;<a class="reference external" href="mailto:alexandre&#46;gramfort&#37;&#52;&#48;inria&#46;fr">alexandre<span>&#46;</span>gramfort<span>&#64;</span>inria<span>&#46;</span>fr</a>&gt;</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> – (np.array), shape (n_samples, n_features)
The data</p></li>
<li><p><strong>y</strong> – (np.array), shape (n_samples,) or (n_samples, 2)
Target labels. If it’s a 2D array, the second column represents
the grouping of samples, i.e., samples with different groups will
not be considered.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(np.array), shape (k, n_feaures)</dt><dd><p>Data as pairs, where k = n_samples * (n_samples-1)) / 2 if grouping
values were not passed. If grouping variables exist, then returns
values computed for each group.</p>
</dd>
<dt>y_trans: (np.array), shape (k,)</dt><dd><p>Output class labels, where classes have values {-1, +1}
If y was shape (n_samples, 2), then returns (k, 2) with groups on
the second dimension.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>X_trans</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.trim">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">trim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#trim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.trim" title="Permalink to this definition">¶</a></dt>
<dd><p>Trim a Pandas DataFrame or Series by replacing outlier values with NaNs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – (pd.DataFrame, pd.Series) data to trim</p></li>
<li><p><strong>cutoff</strong> – (dict) a dictionary with keys {‘std’:[low,high]} or
{‘quantile’:[low,high]}</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(pd.DataFrame, pd.Series) trimmed data</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.two_sample_permutation">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">two_sample_permutation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_perms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#two_sample_permutation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.two_sample_permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Independent sample permutation test.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data1</strong> – (pd.DataFrame, pd.Series, np.array) dataset 1 to permute</p></li>
<li><p><strong>data2</strong> – (pd.DataFrame, pd.Series, np.array) dataset 2 to permute</p></li>
<li><p><strong>n_permute</strong> – (int) number of permutations</p></li>
<li><p><strong>tail</strong> – (int) either 1 for one-tail or 2 for two-tailed test (default: 2)</p></li>
<li><p><strong>n_jobs</strong> – (int) The number of CPUs to use to do the computation.
-1 means all CPUs.</p></li>
<li><p><strong>return_parms</strong> – (bool) Return the permutation distribution along with the p-value; default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(dict) dictionary of permutation results [‘mean’,’p’]</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>stats</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.u_center">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">u_center</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#u_center"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.u_center" title="Permalink to this definition">¶</a></dt>
<dd><p>U-center a 2d array. U-centering is a bias-corrected form of double-centering</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mat</strong> (<em>ndarray</em>) – 2d numpy array</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>u-centered version of input</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>mat (narray)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.upsample">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">upsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'samples'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#upsample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.upsample" title="Permalink to this definition">¶</a></dt>
<dd><p>Upsample pandas to a new target frequency or number of samples using interpolation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – (pd.DataFrame, pd.Series) data to upsample
(Note: will drop non-numeric columns from DataFrame)</p></li>
<li><p><strong>sampling_freq</strong> – Sampling frequency of data in hertz</p></li>
<li><p><strong>target</strong> – (float) upsampling target</p></li>
<li><p><strong>target_type</strong> – (str) type of target can be [samples,seconds,hz]</p></li>
<li><p><strong>method</strong> – (str) [‘linear’, ‘nearest’, ‘zero’, ‘slinear’, ‘quadratic’, ‘cubic’]
where ‘zero’, ‘slinear’, ‘quadratic’ and ‘cubic’
refer to a spline interpolation of zeroth, first,
second or third order  (default: linear)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>upsampled pandas object</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.winsorize">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">winsorize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replace_with_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#winsorize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.winsorize" title="Permalink to this definition">¶</a></dt>
<dd><p>Winsorize a Pandas DataFrame or Series with the largest/lowest value not considered outlier</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – (pd.DataFrame, pd.Series) data to winsorize</p></li>
<li><p><strong>cutoff</strong> – (dict) a dictionary with keys {‘std’:[low,high]} or
{‘quantile’:[low,high]}</p></li>
<li><p><strong>replace_with_cutoff</strong> – (bool) If True, replace outliers with cutoff.
If False, replaces outliers with closest
existing values; (default: False)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(pd.DataFrame, pd.Series) winsorized data</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.stats.zscore">
<span class="sig-prename descclassname"><span class="pre">nltools.stats.</span></span><span class="sig-name descname"><span class="pre">zscore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#zscore"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.zscore" title="Permalink to this definition">¶</a></dt>
<dd><p>zscore every column in a pandas dataframe or series.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>df</strong> – (pd.DataFrame) Pandas DataFrame instance</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(pd.DataFrame) z-scored pandas DataFrame or series instance</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>z_data</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-nltools.datasets">
<span id="nltools-datasets-dataset-tools"></span><h2><a class="reference internal" href="#module-nltools.datasets" title="nltools.datasets"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.datasets</span></code></a>: Dataset Tools<a class="headerlink" href="#module-nltools.datasets" title="Permalink to this heading">¶</a></h2>
<section id="neurolearn-datasets">
<h3>NeuroLearn datasets<a class="headerlink" href="#neurolearn-datasets" title="Permalink to this heading">¶</a></h3>
<p>functions to help download datasets</p>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="nltools.datasets.download_collection">
<span class="sig-prename descclassname"><span class="pre">nltools.datasets.</span></span><span class="sig-name descname"><span class="pre">download_collection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">collection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resume</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/datasets.html#download_collection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.datasets.download_collection" title="Permalink to this definition">¶</a></dt>
<dd><p>Download images and metadata from Neurovault collection</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collection</strong> (<em>int</em><em>, </em><em>optional</em>) – collection id. Defaults to None.</p></li>
<li><p><strong>data_dir</strong> (<em>str</em><em>, </em><em>optional</em>) – data directory. Defaults to None.</p></li>
<li><p><strong>overwrite</strong> (<em>bool</em><em>, </em><em>optional</em>) – overwrite data directory. Defaults to False.</p></li>
<li><p><strong>resume</strong> (<em>bool</em><em>, </em><em>optional</em>) – resume download. Defaults to True.</p></li>
<li><p><strong>verbose</strong> (<em>int</em><em>, </em><em>optional</em>) – print diagnostic messages. Defaults to 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(DataFrame of image metadata, list of files from downloaded collection)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(pd.DataFrame, list)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.datasets.download_nifti">
<span class="sig-prename descclassname"><span class="pre">nltools.datasets.</span></span><span class="sig-name descname"><span class="pre">download_nifti</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">url</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/datasets.html#download_nifti"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.datasets.download_nifti" title="Permalink to this definition">¶</a></dt>
<dd><p>Download a image to a nifti file.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.datasets.fetch_emotion_ratings">
<span class="sig-prename descclassname"><span class="pre">nltools.datasets.</span></span><span class="sig-name descname"><span class="pre">fetch_emotion_ratings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resume</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/datasets.html#fetch_emotion_ratings"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.datasets.fetch_emotion_ratings" title="Permalink to this definition">¶</a></dt>
<dd><p>Download and loads emotion rating dataset from neurovault</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data_dir</strong> – (string, optional). Path of the data directory. Used to force data storage in a specified location. Default: None</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(Brain_Data) Brain_Data object with downloaded data. X=metadata</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.datasets.fetch_pain">
<span class="sig-prename descclassname"><span class="pre">nltools.datasets.</span></span><span class="sig-name descname"><span class="pre">fetch_pain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resume</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/datasets.html#fetch_pain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.datasets.fetch_pain" title="Permalink to this definition">¶</a></dt>
<dd><p>Download and loads pain dataset from neurovault</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data_dir</strong> – (string, optional) Path of the data directory. Used to force data storage in a specified location. Default: None</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(Brain_Data) Brain_Data object with downloaded data. X=metadata</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.datasets.get_collection_image_metadata">
<span class="sig-prename descclassname"><span class="pre">nltools.datasets.</span></span><span class="sig-name descname"><span class="pre">get_collection_image_metadata</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">collection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/datasets.html#get_collection_image_metadata"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.datasets.get_collection_image_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Get image metadata associated with collection</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collection</strong> (<em>int</em><em>, </em><em>optional</em>) – collection id. Defaults to None.</p></li>
<li><p><strong>data_dir</strong> (<em>str</em><em>, </em><em>optional</em>) – data directory. Defaults to None.</p></li>
<li><p><strong>limit</strong> (<em>int</em><em>, </em><em>optional</em>) – number of images to increment. Defaults to 10.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Dataframe with full image metadata from collection</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pd.DataFrame</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-nltools.cross_validation">
<span id="nltools-cross-validation-cross-validation-tools"></span><h2><a class="reference internal" href="#module-nltools.cross_validation" title="nltools.cross_validation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.cross_validation</span></code></a>: Cross-Validation Tools<a class="headerlink" href="#module-nltools.cross_validation" title="Permalink to this heading">¶</a></h2>
<section id="cross-validation-data-classes">
<h3>Cross-Validation Data Classes<a class="headerlink" href="#cross-validation-data-classes" title="Permalink to this heading">¶</a></h3>
<p>Scikit-learn compatible classes for performing various
types of cross-validation</p>
</section>
<dl class="py class">
<dt class="sig sig-object py" id="nltools.cross_validation.KFoldStratified">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">nltools.cross_validation.</span></span><span class="sig-name descname"><span class="pre">KFoldStratified</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_splits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shuffle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/cross_validation.html#KFoldStratified"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.cross_validation.KFoldStratified" title="Permalink to this definition">¶</a></dt>
<dd><p>K-Folds cross validation iterator which stratifies continuous data
(unlike scikit-learn equivalent).</p>
<p>Provides train/test indices to split data in train test sets. Split
dataset into k consecutive folds while ensuring that same subject is
held out within each fold.  Each fold is then used a validation set
once while the k - 1 remaining folds form the training set.
Extension of KFold from scikit-learn cross_validation model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_splits</strong> – int, default=3
Number of folds. Must be at least 2.</p></li>
<li><p><strong>shuffle</strong> – boolean, optional
Whether to shuffle the data before splitting into batches.</p></li>
<li><p><strong>random_state</strong> – None, int or RandomState
Pseudo-random number generator state used for random
sampling. If None, use default numpy RNG for shuffling</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="nltools.cross_validation.KFoldStratified.split">
<span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">groups</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/cross_validation.html#KFoldStratified.split"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.cross_validation.KFoldStratified.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate indices to split data into training and test set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> – array-like, shape (n_samples, n_features)
Training data, where n_samples is the number of samples
and n_features is the number of features.
Note that providing <code class="docutils literal notranslate"><span class="pre">y</span></code> is sufficient to generate the splits
and hence <code class="docutils literal notranslate"><span class="pre">np.zeros(n_samples)</span></code> may be used as a placeholder
for <code class="docutils literal notranslate"><span class="pre">X</span></code> instead of actual training data.</p></li>
<li><p><strong>y</strong> – array-like, shape (n_samples,)
The target variable for supervised learning problems.
Stratification is done based on the y labels.</p></li>
<li><p><strong>groups</strong> – (object) Always ignored, exists for compatibility.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(ndarray) The training set indices for that split.
test : (ndarray) The testing set indices for that split.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>train</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.cross_validation.set_cv">
<span class="sig-prename descclassname"><span class="pre">nltools.cross_validation.</span></span><span class="sig-name descname"><span class="pre">set_cv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cv_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_generator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/cross_validation.html#set_cv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.cross_validation.set_cv" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to create a sci-kit learn compatible cv object using
common parameters for prediction analyses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Y</strong> – (pd.DataFrame) Pandas Dataframe of Y labels</p></li>
<li><p><strong>cv_dict</strong> – (dict) Type of cross_validation to use. A dictionary of
{‘type’: ‘kfolds’, ‘n_folds’: n},
{‘type’: ‘kfolds’, ‘n_folds’: n, ‘stratified’: Y},
{‘type’: ‘kfolds’, ‘n_folds’: n, ‘subject_id’: holdout}, or
{‘type’: ‘loso’, ‘subject_id’: holdout}</p></li>
<li><p><strong>return_generator</strong> (<em>bool</em>) – return a cv generator instead of an instance; default True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a scikit-learn model-selection generator</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>cv</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id0">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">nltools.cross_validation.</span></span><span class="sig-name descname"><span class="pre">KFoldStratified</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_splits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shuffle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/cross_validation.html#KFoldStratified"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id0" title="Permalink to this definition">¶</a></dt>
<dd><p>K-Folds cross validation iterator which stratifies continuous data
(unlike scikit-learn equivalent).</p>
<p>Provides train/test indices to split data in train test sets. Split
dataset into k consecutive folds while ensuring that same subject is
held out within each fold.  Each fold is then used a validation set
once while the k - 1 remaining folds form the training set.
Extension of KFold from scikit-learn cross_validation model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_splits</strong> – int, default=3
Number of folds. Must be at least 2.</p></li>
<li><p><strong>shuffle</strong> – boolean, optional
Whether to shuffle the data before splitting into batches.</p></li>
<li><p><strong>random_state</strong> – None, int or RandomState
Pseudo-random number generator state used for random
sampling. If None, use default numpy RNG for shuffling</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="id3">
<span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">groups</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/cross_validation.html#KFoldStratified.split"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id3" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate indices to split data into training and test set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> – array-like, shape (n_samples, n_features)
Training data, where n_samples is the number of samples
and n_features is the number of features.
Note that providing <code class="docutils literal notranslate"><span class="pre">y</span></code> is sufficient to generate the splits
and hence <code class="docutils literal notranslate"><span class="pre">np.zeros(n_samples)</span></code> may be used as a placeholder
for <code class="docutils literal notranslate"><span class="pre">X</span></code> instead of actual training data.</p></li>
<li><p><strong>y</strong> – array-like, shape (n_samples,)
The target variable for supervised learning problems.
Stratification is done based on the y labels.</p></li>
<li><p><strong>groups</strong> – (object) Always ignored, exists for compatibility.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(ndarray) The training set indices for that split.
test : (ndarray) The testing set indices for that split.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>train</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-nltools.mask">
<span id="nltools-mask-mask-tools"></span><h2><a class="reference internal" href="#module-nltools.mask" title="nltools.mask"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.mask</span></code></a>: Mask Tools<a class="headerlink" href="#module-nltools.mask" title="Permalink to this heading">¶</a></h2>
<section id="neurolearn-mask-classes">
<h3>NeuroLearn Mask Classes<a class="headerlink" href="#neurolearn-mask-classes" title="Permalink to this heading">¶</a></h3>
<p>Classes to represent masks</p>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="nltools.mask.collapse_mask">
<span class="sig-prename descclassname"><span class="pre">nltools.mask.</span></span><span class="sig-name descname"><span class="pre">collapse_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">auto_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">custom_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/mask.html#collapse_mask"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.mask.collapse_mask" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>collapse separate masks into one mask with multiple integers</dt><dd><p>overlapping areas are ignored</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mask</strong> – nibabel or Brain_Data instance</p></li>
<li><p><strong>custom_mask</strong> – nibabel instance or string to file path; optional</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Brain_Data instance of a mask with different integers indicating</dt><dd><p>different masks</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.mask.create_sphere">
<span class="sig-prename descclassname"><span class="pre">nltools.mask.</span></span><span class="sig-name descname"><span class="pre">create_sphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/mask.html#create_sphere"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.mask.create_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a set of spheres in the brain mask space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>radius</strong> – vector of radius.  Will create multiple spheres if
len(radius) &gt; 1</p></li>
<li><p><strong>centers</strong> – a vector of sphere centers of the form [px, py, pz] or
[[px1, py1, pz1], …, [pxn, pyn, pzn]]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.mask.expand_mask">
<span class="sig-prename descclassname"><span class="pre">nltools.mask.</span></span><span class="sig-name descname"><span class="pre">expand_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">custom_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/mask.html#expand_mask"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.mask.expand_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>expand a mask with multiple integers into separate binary masks</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mask</strong> – nibabel or Brain_Data instance</p></li>
<li><p><strong>custom_mask</strong> – nibabel instance or string to file path; optional</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Brain_Data instance of multiple binary masks</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.mask.roi_to_brain">
<span class="sig-prename descclassname"><span class="pre">nltools.mask.</span></span><span class="sig-name descname"><span class="pre">roi_to_brain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/mask.html#roi_to_brain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.mask.roi_to_brain" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will create convert an expanded binary mask of ROIs
(see expand_mask) based on a vector of of values. The dataframe of values
must correspond to ROI numbers.</p>
<p>This is useful for populating a parcellation scheme by a vector of Values</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – Pandas series, dataframe, list, np.array of ROI by observation</p></li>
<li><p><strong>mask_x</strong> – an expanded binary mask</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(Brain_Data) Brain_Data instance where each ROI is now populated</dt><dd><p>with a value</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-nltools.file_reader">
<span id="nltools-file-reader-file-reading"></span><h2><a class="reference internal" href="#module-nltools.file_reader" title="nltools.file_reader"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.file_reader</span></code></a>: File Reading<a class="headerlink" href="#module-nltools.file_reader" title="Permalink to this heading">¶</a></h2>
<section id="neurolearn-file-reading-tools">
<h3>NeuroLearn File Reading Tools<a class="headerlink" href="#neurolearn-file-reading-tools" title="Permalink to this heading">¶</a></h3>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="nltools.file_reader.onsets_to_dm">
<span class="sig-prename descclassname"><span class="pre">nltools.file_reader.</span></span><span class="sig-name descname"><span class="pre">onsets_to_dm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">run_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'infer'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_separate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_poly</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unique_cols</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_na</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/file_reader.html#onsets_to_dm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.file_reader.onsets_to_dm" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>This function can assist in reading in one or several in a 2-3 column onsets files, specified in seconds and converting it to a Design Matrix organized as samples X Stimulus Classes. sampling_freq should be specified in hertz; for TRs use hertz = 1/TR. Onsets files <strong>must</strong> be organized with columns in one of the following 4 formats:</p>
</div></blockquote>
<ol class="arabic simple">
<li><p>‘Stim, Onset’</p></li>
<li><p>‘Onset, Stim’</p></li>
<li><p>‘Stim, Onset, Duration’</p></li>
<li><p>‘Onset, Duration, Stim’</p></li>
</ol>
<p>No other file organizations are currently supported. <em>Note:</em> Stimulus offsets (onset + duration) that fall into an adjacent TR include that full TR. E.g. offset of 10.16s with TR = 2 has an offset of TR 5, which spans 10-12s, rather than an offset of TR 4, which spans 8-10s.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>str/Path/pd.DataFrame</em>) – filepath or pandas dataframe</p></li>
<li><p><strong>sampling_freq</strong> (<em>float</em>) – samping frequency in hertz, i.e 1 / TR</p></li>
<li><p><strong>run_length</strong> (<em>int</em>) – run length in number of TRs</p></li>
<li><p><strong>header</strong> (<em>str/None</em><em>, </em><em>optional</em>) – whether there’s an additional header row in the</p></li>
<li><p><strong>&quot;infer&quot;.</strong> (<em>supplied file/dataframe. See pd.read_csv for more details. Defaults to</em>) – </p></li>
<li><p><strong>sort</strong> (<em>bool</em><em>, </em><em>optional</em>) – whether to sort dataframe columns alphabetically. Defaults to False.</p></li>
<li><p><strong>keep_separate</strong> (<em>bool</em><em>, </em><em>optional</em>) – if a list of files or dataframes is supplied,</p></li>
<li><p><strong>True.</strong> (<em>whether to create separate polynomial columns per file. Defaults to</em>) – </p></li>
<li><p><strong>add_poly</strong> (<em>bool/int</em><em>, </em><em>optional</em>) – whether to add Nth order polynomials to design</p></li>
<li><p><strong>None.</strong> (<em>matrix. Defaults to</em>) – </p></li>
<li><p><strong>unique_cols</strong> (<em>list/None</em><em>, </em><em>optional</em>) – if a list of files or dataframes is supplied,</p></li>
<li><p><strong>file</strong> (<em>what additional columns to keep separate per</em>) – </p></li>
<li><p><strong>fill_na</strong> (<em>Any</em><em>, </em><em>optional</em>) – what to replace NaNs with. Defaults to None (no filling).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>design matrix organized as TRs x Stims</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#nltools.data.Design_Matrix" title="nltools.data.Design_Matrix">nltools.data.Design_Matrix</a></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-nltools.utils">
<span id="nltools-utils-utilities"></span><h2><a class="reference internal" href="#module-nltools.utils" title="nltools.utils"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.utils</span></code></a>: Utilities<a class="headerlink" href="#module-nltools.utils" title="Permalink to this heading">¶</a></h2>
<section id="neurolearn-utilities">
<h3>NeuroLearn Utilities<a class="headerlink" href="#neurolearn-utilities" title="Permalink to this heading">¶</a></h3>
<p>handy utilities.</p>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="nltools.utils.concatenate">
<span class="sig-prename descclassname"><span class="pre">nltools.utils.</span></span><span class="sig-name descname"><span class="pre">concatenate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/utils.html#concatenate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.utils.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate a list of Brain_Data() or Adjacency() objects</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.utils.get_anatomical">
<span class="sig-prename descclassname"><span class="pre">nltools.utils.</span></span><span class="sig-name descname"><span class="pre">get_anatomical</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/utils.html#get_anatomical"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.utils.get_anatomical" title="Permalink to this definition">¶</a></dt>
<dd><p>Get nltools default anatomical image.
DEPRECATED. See MNI_Template and resolve_mni_path from nltools.prefs</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.utils.get_resource_path">
<span class="sig-prename descclassname"><span class="pre">nltools.utils.</span></span><span class="sig-name descname"><span class="pre">get_resource_path</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/utils.html#get_resource_path"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.utils.get_resource_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Get path to nltools resource directory.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.utils.set_algorithm">
<span class="sig-prename descclassname"><span class="pre">nltools.utils.</span></span><span class="sig-name descname"><span class="pre">set_algorithm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/utils.html#set_algorithm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.utils.set_algorithm" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup the algorithm to use in subsequent prediction analyses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>algorithm</strong> – The prediction algorithm to use. Either a string or an
(uninitialized) scikit-learn prediction object. If string,
must be one of ‘svm’,’svr’, linear’,’logistic’,’lasso’,
‘lassopcr’,’lassoCV’,’ridge’,’ridgeCV’,’ridgeClassifier’,
‘randomforest’, or ‘randomforestClassifier’</p></li>
<li><p><strong>kwargs</strong> – Additional keyword arguments to pass onto the scikit-learn
clustering object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>dictionary of settings for prediction</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>predictor_settings</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.utils.set_decomposition_algorithm">
<span class="sig-prename descclassname"><span class="pre">nltools.utils.</span></span><span class="sig-name descname"><span class="pre">set_decomposition_algorithm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_components</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/utils.html#set_decomposition_algorithm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.utils.set_decomposition_algorithm" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup the algorithm to use in subsequent decomposition analyses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>algorithm</strong> – The decomposition algorithm to use. Either a string or an
(uninitialized) scikit-learn decomposition object.
If string must be one of ‘pca’,’nnmf’, ica’,’fa’,
‘dictionary’, ‘kernelpca’.</p></li>
<li><p><strong>kwargs</strong> – Additional keyword arguments to pass onto the scikit-learn
clustering object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>dictionary of settings for prediction</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>predictor_settings</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="nltools-prefs-preferences">
<h2><a class="reference internal" href="#module-nltools.prefs" title="nltools.prefs"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.prefs</span></code></a>: Preferences<a class="headerlink" href="#nltools-prefs-preferences" title="Permalink to this heading">¶</a></h2>
<p>This module can be used to adjust the default MNI template settings that are used
internally by all <cite>Brain_Data</cite> operations. By default all operations are performed in
<strong>MNI152 2mm space</strong>. Thus any files loaded with be resampled to this space by default.You can control this on a per-file loading basis using the <cite>mask</cite> argument of <cite>Brain_Data</cite>, e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">nltools.data</span> <span class="kn">import</span> <span class="n">Brain_Data</span>

<span class="c1"># my_brain will be resampled to 2mm</span>
<span class="n">brain</span> <span class="o">=</span> <span class="n">Brain_Data</span><span class="p">(</span><span class="s1">&#39;my_brain.nii.gz&#39;</span><span class="p">)</span>

<span class="c1"># my_brain will now be resampled to the same space as my_mask</span>
<span class="n">brain</span> <span class="o">=</span> <span class="n">Brain_Data</span><span class="p">(</span><span class="s1">&#39;my_brain.nii.gz&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;my_mask.nii.gz&#39;</span><span class="p">)</span> <span class="c1"># will be resampled</span>
</pre></div>
</div>
<p>Alternatively this module can be used to switch between 2mm or 3mm MNI spaces with and without ventricles:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">nltools.prefs</span> <span class="kn">import</span> <span class="n">MNI_Template</span><span class="p">,</span> <span class="n">resolve_mni_path</span>
<span class="kn">from</span> <span class="nn">nltools.data</span> <span class="kn">import</span> <span class="n">Brain_Data</span>

<span class="c1"># Update the resolution globally</span>
<span class="n">MNI_Template</span><span class="p">[</span><span class="s1">&#39;resolution&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;3mm&#39;</span>

<span class="c1"># This works too:</span>
<span class="n">MNI_Template</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="mi">3</span>

<span class="c1"># my_brain will be resampled to 3mm and future operation will be in 3mm space</span>
<span class="n">brain</span> <span class="o">=</span> <span class="n">Brain_Data</span><span class="p">(</span><span class="s1">&#39;my_brain.nii.gz&#39;</span><span class="p">)</span>

<span class="c1"># get the template nifti files</span>
<span class="n">resolve_mni_path</span><span class="p">(</span><span class="n">MNI_Template</span><span class="p">)</span>

<span class="c1"># will print like:</span>
<span class="p">{</span>
    <span class="s1">&#39;resolution&#39;</span><span class="p">:</span> <span class="s1">&#39;3mm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mask_type&#39;</span><span class="p">:</span> <span class="s1">&#39;with_ventricles&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mask&#39;</span><span class="p">:</span> <span class="s1">&#39;/Users/Esh/Documents/pypackages/nltools/nltools/resources/MNI152_T1_3mm_brain_mask.nii.gz&#39;</span><span class="p">,</span>
    <span class="s1">&#39;plot&#39;</span><span class="p">:</span> <span class="s1">&#39;/Users/Esh/Documents/pypackages/nltools/nltools/resources/MNI152_T1_3mm.nii.gz&#39;</span><span class="p">,</span>
    <span class="s1">&#39;brain&#39;</span><span class="p">:</span>
    <span class="s1">&#39;/Users/Esh/Documents/pypackages/nltools/nltools/resources/MNI152_T1_3mm_brain.nii.gz&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<span class="target" id="module-nltools.prefs"></span><dl class="py function">
<dt class="sig sig-object py" id="nltools.prefs.resolve_mni_path">
<span class="sig-prename descclassname"><span class="pre">nltools.prefs.</span></span><span class="sig-name descname"><span class="pre">resolve_mni_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">MNI_Template</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/prefs.html#resolve_mni_path"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.prefs.resolve_mni_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to resolve MNI path based on MNI_Template prefs setting.</p>
</dd></dl>

</section>
<section id="module-nltools.plotting">
<span id="nltools-plotting-plotting-tools"></span><h2><a class="reference internal" href="#module-nltools.plotting" title="nltools.plotting"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.plotting</span></code></a>: Plotting Tools<a class="headerlink" href="#module-nltools.plotting" title="Permalink to this heading">¶</a></h2>
<section id="neurolearn-plotting-tools">
<h3>NeuroLearn Plotting Tools<a class="headerlink" href="#neurolearn-plotting-tools" title="Permalink to this heading">¶</a></h3>
<p>Numerous functions to plot data</p>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="nltools.plotting.dist_from_hyperplane_plot">
<span class="sig-prename descclassname"><span class="pre">nltools.plotting.</span></span><span class="sig-name descname"><span class="pre">dist_from_hyperplane_plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stats_output</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/plotting.html#dist_from_hyperplane_plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.plotting.dist_from_hyperplane_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot SVM Classification Distance from Hyperplane</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>stats_output</strong> – a pandas file with prediction output</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Will return a seaborn plot of distance from hyperplane</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>fig</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.plotting.plot_between_label_distance">
<span class="sig-prename descclassname"><span class="pre">nltools.plotting.</span></span><span class="sig-name descname"><span class="pre">plot_between_label_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permutation_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fontsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">18</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/plotting.html#plot_between_label_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.plotting.plot_between_label_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a heatmap indicating average between label distance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>distance</strong> – (pandas dataframe) brain_distance matrix</p></li>
<li><p><strong>labels</strong> – (pandas dataframe) group labels</p></li>
<li><p><strong>ax</strong> – axis to plot (default=None)</p></li>
<li><p><strong>permutation_test</strong> – (boolean)</p></li>
<li><p><strong>n_permute</strong> – (int) number of samples for permuation test</p></li>
<li><p><strong>fontsize</strong> – (int) size of font for plot</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>heatmap
out: pandas dataframe of pairwise distance between conditions
within_dist_out: average pairwise distance matrix
mn_dist_out: (optional if permutation_test=True) average difference in distance between conditions
p_dist_out: (optional if permutation_test=True) p-value for difference in distance between conditions</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>f</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.plotting.plot_brain">
<span class="sig-prename descclassname"><span class="pre">nltools.plotting.</span></span><span class="sig-name descname"><span class="pre">plot_brain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">objIn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">how</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'full'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thr_upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thr_lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/plotting.html#plot_brain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.plotting.plot_brain" title="Permalink to this definition">¶</a></dt>
<dd><p>More complete brain plotting of a Brain_Data instance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> (<a class="reference internal" href="#nltools.data.Brain_Data" title="nltools.data.Brain_Data"><em>Brain_Data</em></a>) – object to plot</p></li>
<li><p><strong>how</strong> (<em>str</em>) – whether to plot a glass brain ‘glass’, 3 view-multi-slice mni ‘mni’, or both ‘full’</p></li>
<li><p><strong>thr_upper</strong> (<em>str/float</em>) – thresholding of image. Can be string for percentage, or float for data units (see Brain_Data.threshold()</p></li>
<li><p><strong>thr_lower</strong> (<em>str/float</em>) – thresholding of image. Can be string for percentage, or float for data units (see Brain_Data.threshold()</p></li>
<li><p><strong>save</strong> (<em>str</em>) – if a string file name or path is provided plots will be saved into this directory appended with the orientation they belong to</p></li>
<li><p><strong>kwargs</strong> – optionals args to nilearn plot functions (e.g. vmax)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.plotting.plot_interactive_brain">
<span class="sig-prename descclassname"><span class="pre">nltools.plotting.</span></span><span class="sig-name descname"><span class="pre">plot_interactive_brain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">brain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentile_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anatomical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/plotting.html#plot_interactive_brain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.plotting.plot_interactive_brain" title="Permalink to this definition">¶</a></dt>
<dd><p>This function leverages nilearn’s new javascript based brain viewer functions to create interactive plotting functionality.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>brain</strong> (<em>nltools.Brain_Data</em>) – a Brain_Data instance of 1d or 2d shape (i.e. 3d or 4d volume)</p></li>
<li><p><strong>threshold</strong> (<em>float/str</em>) – threshold to initialize the visualization, maybe be a percentile string; default 0</p></li>
<li><p><strong>surface</strong> (<em>bool</em>) – whether to create a surface-based plot; default False</p></li>
<li><p><strong>percentile_threshold</strong> (<em>bool</em>) – whether to interpret threshold values as percentiles</p></li>
<li><p><strong>kwargs</strong> – optional arguments to nilearn.view_img or nilearn.view_img_on_surf</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>interactive brain viewer widget</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.plotting.plot_mean_label_distance">
<span class="sig-prename descclassname"><span class="pre">nltools.plotting.</span></span><span class="sig-name descname"><span class="pre">plot_mean_label_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permutation_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fontsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">18</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/plotting.html#plot_mean_label_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.plotting.plot_mean_label_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a violin plot indicating within and between label distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>distance</strong> – pandas dataframe of distance</p></li>
<li><p><strong>labels</strong> – labels indicating columns and rows to group</p></li>
<li><p><strong>ax</strong> – matplotlib axis to plot on</p></li>
<li><p><strong>permutation_test</strong> – (bool) indicates whether to run permuatation test or not</p></li>
<li><p><strong>n_permute</strong> – (int) number of permutations to run</p></li>
<li><p><strong>fontsize</strong> – (int) fontsize for plot labels</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>heatmap
stats: (optional if permutation_test=True) permutation results</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>f</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.plotting.plot_silhouette">
<span class="sig-prename descclassname"><span class="pre">nltools.plotting.</span></span><span class="sig-name descname"><span class="pre">plot_silhouette</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permutation_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/plotting.html#plot_silhouette"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.plotting.plot_silhouette" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a silhouette plot indicating between relative to within label distance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>distance</strong> – (pandas dataframe) brain_distance matrix</p></li>
<li><p><strong>labels</strong> – (pandas dataframe) group labels</p></li>
<li><p><strong>ax</strong> – axis to plot (default=None)</p></li>
<li><p><strong>permutation_test</strong> – (boolean)</p></li>
<li><p><strong>n_permute</strong> – (int) number of samples for permuation test</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Optional keyword args:</dt><dd><p>figsize: (list) dimensions of silhouette plot
colors: (list) color triplets for silhouettes. Length must equal number of unique labels</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>heatmap
# out: pandas dataframe of pairwise distance between conditions
# within_dist_out: average pairwise distance matrix
# mn_dist_out: (optional if permutation_test=True) average difference in distance between conditions
# p_dist_out: (optional if permutation_test=True) p-value for difference in distance between conditions</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p># f</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.plotting.plot_stacked_adjacency">
<span class="sig-prename descclassname"><span class="pre">nltools.plotting.</span></span><span class="sig-name descname"><span class="pre">plot_stacked_adjacency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adjacency1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adjacency2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/plotting.html#plot_stacked_adjacency"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.plotting.plot_stacked_adjacency" title="Permalink to this definition">¶</a></dt>
<dd><p>Create stacked adjacency to illustrate similarity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matrix1</strong> – Adjacency instance 1</p></li>
<li><p><strong>matrix2</strong> – Adjacency instance 2</p></li>
<li><p><strong>normalize</strong> – (boolean) Normalize matrices.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>matplotlib figure</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.plotting.plot_t_brain">
<span class="sig-prename descclassname"><span class="pre">nltools.plotting.</span></span><span class="sig-name descname"><span class="pre">plot_t_brain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">objIn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">how</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'full'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'unc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nperm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cut_coords</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/plotting.html#plot_t_brain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.plotting.plot_t_brain" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a brain data object and computes a 1 sample t-test across it’s first axis. If a list is provided will compute difference between brain data objects in list (i.e. paired samples t-test).
:param objIn: if list will compute difference map first
:type objIn: list/Brain_Data
:param how: whether to plot a glass brain ‘glass’, 3 view-multi-slice mni ‘mni’, or both ‘full’
:type how: list
:param thr: what method to use for multiple comparisons correction unc, fdr, or tfce
:type thr: str
:param alpha: p-value threshold
:type alpha: float
:param nperm: number of permutations for tcfe; default 1000
:type nperm: int
:param cut_coords: x,y,z coords to plot brain slice
:type cut_coords: list
:param kwargs: optionals args to nilearn plot functions (e.g. vmax)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.plotting.probability_plot">
<span class="sig-prename descclassname"><span class="pre">nltools.plotting.</span></span><span class="sig-name descname"><span class="pre">probability_plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stats_output</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/plotting.html#probability_plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.plotting.probability_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot Classification Probability</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>stats_output</strong> – a pandas file with prediction output</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Will return a seaborn scatterplot</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>fig</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.plotting.roc_plot">
<span class="sig-prename descclassname"><span class="pre">nltools.plotting.</span></span><span class="sig-name descname"><span class="pre">roc_plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fpr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tpr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/plotting.html#roc_plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.plotting.roc_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot 1-Specificity by Sensitivity</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fpr</strong> – false positive rate from Roc.calculate</p></li>
<li><p><strong>tpr</strong> – true positive rate from Roc.calculate</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Will return a matplotlib ROC plot</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>fig</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nltools.plotting.scatterplot">
<span class="sig-prename descclassname"><span class="pre">nltools.plotting.</span></span><span class="sig-name descname"><span class="pre">scatterplot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stats_output</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/plotting.html#scatterplot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.plotting.scatterplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot Prediction Scatterplot</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>stats_output</strong> – a pandas file with prediction output</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Will return a seaborn scatterplot</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>fig</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-nltools.simulator">
<span id="nltools-simulator-simulator-tools"></span><h2><a class="reference internal" href="#module-nltools.simulator" title="nltools.simulator"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.simulator</span></code></a>: Simulator Tools<a class="headerlink" href="#module-nltools.simulator" title="Permalink to this heading">¶</a></h2>
<section id="neurolearn-simulator-tools">
<h3>NeuroLearn Simulator Tools<a class="headerlink" href="#neurolearn-simulator-tools" title="Permalink to this heading">¶</a></h3>
<p>Tools to simulate multivariate data.</p>
</section>
<dl class="py class">
<dt class="sig sig-object py" id="nltools.simulator.Simulator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">nltools.simulator.</span></span><span class="sig-name descname"><span class="pre">Simulator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">brain_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/simulator.html#Simulator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.simulator.Simulator" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="nltools.simulator.Simulator.create_cov_data">
<span class="sig-name descname"><span class="pre">create_cov_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_sub</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/simulator.html#Simulator.create_cov_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.simulator.Simulator.create_cov_data" title="Permalink to this definition">¶</a></dt>
<dd><p>create continuous simulated data with covariance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cor</strong> – amount of covariance between each voxel and Y variable</p></li>
<li><p><strong>cov</strong> – amount of covariance between voxels</p></li>
<li><p><strong>sigma</strong> – amount of noise to add</p></li>
<li><p><strong>radius</strong> – vector of radius.  Will create multiple spheres if len(radius) &gt; 1</p></li>
<li><p><strong>center</strong> – center(s) of sphere(s) of the form [px, py, pz] or [[px1, py1, pz1], …, [pxn, pyn, pzn]]</p></li>
<li><p><strong>reps</strong> – number of data repetitions</p></li>
<li><p><strong>n_sub</strong> – number of subjects to simulate</p></li>
<li><p><strong>output_dir</strong> – string path of directory to output data.  If None, no data will be written</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments to pass to the prediction algorithm</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.simulator.Simulator.create_data">
<span class="sig-name descname"><span class="pre">create_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">levels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/simulator.html#Simulator.create_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.simulator.Simulator.create_data" title="Permalink to this definition">¶</a></dt>
<dd><p>create simulated data with integers</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>levels</strong> – vector of intensities or class labels</p></li>
<li><p><strong>sigma</strong> – amount of noise to add</p></li>
<li><p><strong>radius</strong> – vector of radius.  Will create multiple spheres if len(radius) &gt; 1</p></li>
<li><p><strong>center</strong> – center(s) of sphere(s) of the form [px, py, pz] or [[px1, py1, pz1], …, [pxn, pyn, pzn]]</p></li>
<li><p><strong>reps</strong> – number of data repetitions useful for trials or subjects</p></li>
<li><p><strong>output_dir</strong> – string path of directory to output data.  If None, no data will be written</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments to pass to the prediction algorithm</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.simulator.Simulator.create_ncov_data">
<span class="sig-name descname"><span class="pre">create_ncov_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">masks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_sub</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/simulator.html#Simulator.create_ncov_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.simulator.Simulator.create_ncov_data" title="Permalink to this definition">¶</a></dt>
<dd><p>create continuous simulated data with covariance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cor</strong> – amount of covariance between each voxel and Y variable (an int or a vector)</p></li>
<li><p><strong>cov</strong> – amount of covariance between voxels (an int or a matrix)</p></li>
<li><p><strong>sigma</strong> – amount of noise to add</p></li>
<li><p><strong>mask</strong> – region(s) where we will have activations (list if more than one)</p></li>
<li><p><strong>reps</strong> – number of data repetitions</p></li>
<li><p><strong>n_sub</strong> – number of subjects to simulate</p></li>
<li><p><strong>output_dir</strong> – string path of directory to output data.  If None, no data will be written</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments to pass to the prediction algorithm</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.simulator.Simulator.gaussian">
<span class="sig-name descname"><span class="pre">gaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i_tot</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/simulator.html#Simulator.gaussian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.simulator.Simulator.gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>create a 3D gaussian signal normalized to a given intensity</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mu</strong> – average value of the gaussian signal (usually set to 0)</p></li>
<li><p><strong>sigma</strong> – standard deviation</p></li>
<li><p><strong>i_tot</strong> – sum total of activation (numerical integral over the gaussian returns this value)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.simulator.Simulator.n_spheres">
<span class="sig-name descname"><span class="pre">n_spheres</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/simulator.html#Simulator.n_spheres"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.simulator.Simulator.n_spheres" title="Permalink to this definition">¶</a></dt>
<dd><p>generate a set of spheres in the brain mask space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>radius</strong> – vector of radius.  Will create multiple spheres if len(radius) &gt; 1</p></li>
<li><p><strong>centers</strong> – a vector of sphere centers of the form [px, py, pz] or [[px1, py1, pz1], …, [pxn, pyn, pzn]]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.simulator.Simulator.normal_noise">
<span class="sig-name descname"><span class="pre">normal_noise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/simulator.html#Simulator.normal_noise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.simulator.Simulator.normal_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>produce a normal noise distribution for all all points in the brain mask</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mu</strong> – average value of the gaussian signal (usually set to 0)</p></li>
<li><p><strong>sigma</strong> – standard deviation</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.simulator.Simulator.sphere">
<span class="sig-name descname"><span class="pre">sphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/simulator.html#Simulator.sphere"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.simulator.Simulator.sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>create a sphere of given radius at some point p in the brain mask</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> – radius of the sphere</p></li>
<li><p><strong>p</strong> – point (in coordinates of the brain mask) of the center of the sphere</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nltools.simulator.Simulator.to_nifti">
<span class="sig-name descname"><span class="pre">to_nifti</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/simulator.html#Simulator.to_nifti"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.simulator.Simulator.to_nifti" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a numpy matrix to the nifti format and assign to it the brain_mask’s affine matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>m</strong> – the 3D numpy matrix we wish to convert to .nii</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="index">
<h2>Index<a class="headerlink" href="#index" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
</ul>
</section>
</section>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="_sources/api.rst.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2023, Cosan Laboratory.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 7.1.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>